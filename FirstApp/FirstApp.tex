% $Author: oscar $
% $Date: 2009-09-28 17:41:15 +0600 (пн, 28 сен 2009) $
% $Revision: 29309 $

% HISTORY:
% 2006-12-05 - Stef started
% 2006-12-30 - Andrew new material
% 2007-01-10 - Stef edit
% 2007-01-12 - Andrew edit
% 2007-06-07 - Oscar edit
% 2007-07-03 - Stef edit
% 2007-09-06 - Lukas review
% 2007-09-06 - Cassou corrections
% 2007-09-24 - Cassou review
% 2009-07-01 - Oscar migrated to Pharo

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
%\chapter{A first application}
\chapter{Первое приложение}
\chalabel{firstApp}

%In this chapter, we will develop a simple game: \ind{Lights Out}.\footnote{\url{http://en.wikipedia.org/wiki/Lights_Out_(game)}}
В этой главе мы займёмся разработкой простой игры <<\ind{Lights Out}>>.\footnote{\url{http://en.wikipedia.org/wiki/Lights_Out_(game)}}
%Along the way we will demonstrate most of the tools that \pharo programmers use to construct and debug their programs, and show how programs are exchanged with other developers. We will see the browser, the object inspector, the debugger and the \ind{Monticello} \ind{package} browser. 
По ходу разработки мы будем демонстрировать инструменты, которые программисты \pharo используют для написания и отладки своих программ, а также способы обмена программами с другими разработчиками. Вы познакомитесь с браузером, инспектором объектов, отладчиком и браузером \ind{пакет}ов \ind{Monticello}.
%Development in Smalltalk is efficient: you will find that you spend far more time actually writing code and far less managing the development process. 
Разработка в среде \st весьма эффективна: вы вскоре обнаружите, что тратите б'ольшую часть времени непосредственно на написание кода, а не на управление процессом разработки.
%This is partly because the Smalltalk language is very simple, and partly because the tools that make up the programming environment are very well integrated with the language.
Частично это происходит из-за необычайной простоты языка \st, и частично потому, что инструменты, составляющие окружение разработчика, очень тесно интегрированы с языком.

%=================================================================
%\section{The Lights Out game}
\section{Игра <<Lights Out>>}

% DON'T USE WRAPFIGURE CLOSE TOO A PAGE BREAK!!! (ON)
%\begin{wrapfigure}[13]{r}{0.35\linewidth}%
%	\vskip -\baselineskip
%	\centerline{\includegraphics[width=.8\linewidth]{GameBoard}}
%	\caption{The Lights Out game board. The user has just clicked the mouse as shown by the cursor.
%	\figlabel{gameBoard}}
%\end{wrapfigure}

\begin{figure}[ht]
	\vskip -\baselineskip
	\centerline{\includegraphics[width=.3\linewidth]{GameBoard}}
	%\caption{The Lights Out game board. The user has just clicked the mouse as shown by the cursor.
	\caption{Поле игры <<Lights Out>>. Пользователь только что кликнул мышью в месте, на которое указывает курсор.
	\figlabel{gameBoard}}
\end{figure}

%To show you how to use \pharo's programming tools, we will build a simple game called \emph{Lights Out}.  The game board is shown in \figref{gameBoard}; it consists of rectangular array of light yellow \emph{cells}.  When you click on one of the cells with the mouse, the four surrounding cells turn blue.  \Click again, and they toggle back to light yellow.  The object of the game is to turn blue as many cells as possible.
Чтобы показать вам, как использовать инструменты программирования \pharo, мы разработаем простую игру <<\emph{Lights Out}>>. Поле игры показано на \figref{gameBoard}. Оно состоит из прямоугольного набора светложёлтых \emph{ячеек}. Когда вы кликаете мышью на одной из них, четыре ячейки, располагающиеся по её сторонам становятся голубыми. Повторный клик возвращает ячейкам прежний цвет. Цель игры --- сделать как можно больше ячеек голубыми.

%The Lights Out game shown in \figref{gameBoard} is made up of two kinds of objects: the game board itself, and 100 individual cell objects.  The \pharo code to implement the game will contain two classes: one for the game and one for the cells.
Игра <<Lights Out>>, показанная на \figref{gameBoard}, состоит из объектов двух типов: собственно игрового поля и ста объектов-ячеек.  Реализация этой игры в \pharo будет содержать два класса: один для игры и один для ячеек.
%We will now show you how to define these classes using the \pharo programming tools.
Далее мы покажем вам, как определить эти классы, используя инструменты для программирования, доступные в \pharo.

%=================================================================
%\section{Creating a new Package}
\section{Создание нового пакета}

%We have already seen the \ind{browser} in \charef{quick}, where we learned how to navigate to classes and methods, and saw how to define new methods.
Мы уже видели \ind{браузер} в \charef{quick}, в которой мы изучили, как осуществлять навигация по классам и методам, а также узнали, как определять новые методы.
%Now we will see how to create packages, categories and classes.
Теперь мы рассмотрим создание пакетов, категорий и классов.
\index{category!creating}
\index{package!creating}

%\dothis{Open a browser and \actclick in the package pane.
\dothis{Откройте браузер и сделайте \actclick на панели пакетов.
%Select \menu{create package}.\footnote{We are assuming that the Package Browser is installed as the default browser, which should normally be the case. If the browser you get does not look like the one shown in \figref{addPackage}, then you may need to change the default browser.  See \faqref{packagebrowser}.}}
Выберите \menu{create package}.\footnote{Мы предполагаем, что браузер пакетов (Package Browser) установлен в качестве браузера по-умолчанию (как и должно быть в норме). Если браузер, который вы видите, не похож на изображённый на \figref{addPackage}, вам будет нужно поменять его (см. \faqref{packagebrowser}).}}

\begin{figure}[htb]
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.9\textwidth]{AddPackage}}}
	{\centerline {\includegraphics[scale=0.7]{AddPackage}}}
	%\caption{Adding a package.
	\caption{Добавление пакета.
	\figlabel{addPackage}}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\textwidth}
\ifluluelse
	{\centerline {\includegraphics[width=0.8\textwidth]{ClassTemplate}}}
	{\centerline {\includegraphics[scale=0.6]{ClassTemplate}}}
	%\caption{The class template.
	\caption{Шаблон класса.
	\figlabel{classTemplate}}
\end{minipage}
\end{figure}

%Type the name of the new package (we will use \scat{PBE-LightsOut}) in the dialog box and click \menu{accept} (or just press the return key); the new package is created, and positioned alphabetically in the list of packages.
Введите имя нового пакета (мы используем \scat{PBE-LightsOut}) в окне диалога и нажмите \menu{accept} (принять) или просто нажмите клавишу <<ввод>>. Всё, новый пакет создан и располагается согласно алфавиту в списке пакетов.

%=================================================================
%\section{Defining the class LOCell}
\section{Определение класса LOCell}

%As yet there are  of course no classes in the new package. However, the main editing pane displays a template to make it easy to create a new class (see \figref{classTemplate}).
Разумеется, пока в новом пакете нет никаких классов. Однако в главной панели редактирования отображается шаблон, облегчающий создание нового класса (см. \figref{classTemplate}).

%This template shows us a \st expression that sends a message to a class called \ct{Object}, asking it to create a subclass called \ct{NameOfSubClass}.  The new class has no variables, and should belong to the category \scat{PBE-LightsOut}.
Этот шаблон представляет собой выражение на языке \st, посылающее сообщение классу \ct{Object} с тем, чтобы создать его подкласс с названием \ct{NameOfSubClass}. Новый класс не имеет переменных, и относится к категории \scat{PBE-LightsOut}.

%\subsection{On Categories and Packages}
\subsection{О категориях и пакетах}
\seclabel{categoriesPackages}

%Historically, \st only knows about \emph{categories}, not packages.
Исторически сложилось так, что \st знает только о \emph{категориях}, но не о пакетах.
%You may well ask, what is the difference?
Вы спросите, а в чём же разница?
%A category is simply a collection of related classes in a \st image.
Категория -- это просто совокупность связнных классов в образе \st.
%A \emph{package} is a collection of related classes \emph{and extension methods} that may be versioned using the Monticello versioning tool.
\emph{Пакет} же представляет собой набор связанных классов и \emph{методов-расширений}, которые могут быть версионированы с использованием систему управления версиями Monticello.
%By convention, package names and category names are the same.
По принятому соглашению, имена пакетов и категорий совпадают.
%For most purposes we do not care about the difference, but we will be careful to use the correct terminology in this book since there are points where the difference is crucial.
В большинстве случаев нам не важна эта разница, но в этой книге мы будем последовательно применять правильную терминологию, т.к. иногда разница между этими двумя понятиями становится очень важной.
%We will learn more when we start working with Monticello.
Мы узнаем о них больше, когда начнём работать с Monticello.
\index{package}
\index{category}

%\subsection{Creating a new class}
\subsection{Создание нового класса}

%We simply modify the template to create the class that we really want.
Мы просто модифицирем шаблон, чтобы создать тот класс, который нам действительно нужен.

%\dothis{Modify the class creation template as follows:}
\dothis{Измените шаблон создания класса следующим образом:}
\begin{itemize}
%  \item Replace \clsind{Object} by \clsind{SimpleSwitchMorph}.
  \item Замените \clsind{Object} на \clsind{SimpleSwitchMorph}.
%  \item Replace \ct{NameOfSubClass} by \clsind{LOCell}.
  \item Замените \ct{NameOfSubClass} на \clsind{LOCell}.
%  \item Add \ct{mouseAction} to the list of instance variables.
  \item Добавьте \ct{mouseAction} в список переменных экземпляра.
\end{itemize}
%The result should look like \clsref{firstClassDef}.
Результат должен выглядеть как на \clsref{firstClassDef}.

\needlines{5}
%\begin{classdef}[firstClassDef]{Defining the class \ct| LOCell|}
\begin{classdef}[firstClassDef]{Определение класса \ct| LOCell|}
SimpleSwitchMorph subclass: #LOCell
   instanceVariableNames: 'mouseAction'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PBE-LightsOut'
\end{classdef}
\index{browser!defining a class}
\index{class!creation}
\index{Morphic}

%This new definition consists of a \st expression that sends a message to the existing class \ct{SimpleSwitchMorph}, asking it to create a subclass called \ct{LOCell}.
Это новое определение состоит из \st-выражения, посылающего сообщение существующему классу \ct{SimpleSwitchMorph} с целью создания подкласса, названного \ct{LOCell}.
%(Actually, since \ct{LOCell} does not exist yet, we passed as an argument the \emphind{symbol} \ct{#LOCell} which stands for the name of the class to create.)
(На самом деле, т.к. класс \ct{LOCell} ещё не существует, мы передаём в качестве параметра \emphind{символ} \ct{#LOCell} обозначающий имя создаваемого класса.)
%We also tell it that instances of the new class should have a \ct{mouseAction} instance variable, which we will use to define what action the cell should take if the mouse should click over it.
Мы также указываем, что экземпляры нового класса должны иметь переменную экземпляра \ct{mouseAction}, которую мы будем использовать, чтобы определить, какое действие должна совершить ячейка при клике по ней мышью.

%\emph{At this point you still have not created anything.}
\emph{В этот момент вы ещё ничего не создали.}
%Note that the border of the class template pane has changed to red (\figref{acceptClassDef}).
Обратите внимание на то, что обрамление панели шаблона класса стало красным (\figref{acceptClassDef}).
%This means that there are \emph{unsaved changes}.
Это означает, что имеютя \emph{несохранённые изменения}.
%To actually send this message, you must \menu{accept} it.
Чтобы, наконец, послать упомянутое сообщение, вы должны принять (\menu{accept}) их.

\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{AcceptClassDef}}}
	{\centerline {\includegraphics[scale=0.7]{AcceptClassDef}}}
%\caption{The class-creation Template.
\caption{Шаблон создания класса.
\figlabel{acceptClassDef}}
\end{figure}

%\dothis{Accept the new class definition.}
\dothis{Примите новое определение класса.}
%Either \actclick and select \menu{accept}, or use the shortcut \short{s} (for ``save'').
Либо сделайте \actclick и выберите \menu{accept}, либо используйте сочетание клавиш \short{s} (от <<save>> -- сохранить).
%The message will be sent to \ct{SimpleSwitchMorph}, which will cause the new class to be compiled.
Сообщение будет послано классу \ct{SimpleSwitchMorph}, который скомпилирует новый класс.
\index{keyboard shortcut!accept}

%Once the class definition is accepted, the class will be created and appear in the classes pane of the browser (\figref{LOCell}).
После того, как было принято определение класса, он создаётся и отображается в браузере на панели классов (\figref{LOCell}).
%The editing pane now shows the class definition, and a small pane below it will remind you to write a few words describing the purpose of the class. This is called a \emph{class comment}, and it is quite important to write one that will give other programmers a high-level overview of the purpose of this class.
Панель редактирования показывает определение класса, а небольшая панель под ней напоминает вам о необходимости написать пару слов о назначении этого класса. Это называется \emph{комментарий класса} (\emph{class comment}), и он важен, т.к. даёт другим программистам общее представление о предназначении класса.
%Smalltalkers put a very high value on the readability of their code, and detailed comments in methods are unusual: the philosophy is that the code should speak for itself. (If it doesn't, you should refactor it until it does!) A class \subind{class}{comment} need not contain a detailed description of the class, but a few words describing its overall purpose are vital if programmers who come after you are to know whether to spend time looking at this class.
Программисты на \st придают большое значение читабельности своего кода, и подробные комментарии в методах --- вещь весьма необычная, ведь их философия заключается в том, что код должен говорить сам за себя. (Если это не так, сделайте рефакторинг!) \subind{class}{Комментарий} класса не обязан содержать детальное его описание, но несколько слов о его общем назначении могут очень помочь программистам, которые потом будут иметь дело с вашим классом.
\index{refactoring}

%\dothis{Type a class comment for \ct{LOCell} and accept it; you can always improve it later.}
\dothis{Напишите комментарий для класса \ct{LOCell} и примите его. Позже вы всегда сможете вернуться и дополнить его.}

\begin{figure}[h!t]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{LOCell}}}
	{\centerline {\includegraphics[scale=0.7]{LOCell}}}
%\caption{The newly-created class \ct{LOCell}\figlabel{LOCell}}
\caption{Вновь созданный класс \ct{LOCell}\figlabel{LOCell}}
\end{figure}

%=================================================================
%\section{Adding methods to a class}
\section{Добавление новых методов}

%Now let's add some methods to our class.
Давайте теперь добавим несколько методов в наш класс.

%\dothis{Select the protocol \prot{-{}-all-{}-} in the protocol pane.}
\dothis{Выберите протокол \prot{-{}-all-{}-} на панели протоколов.}
%You will see a template for method creation in the editing pane.
На панели редактирования вы увидите шаблон создания метода.
%Select it, and replace it by the text of \mthref{scbecellinitialize}.
Выделите его и замените его текстом \mthref{scbecellinitialize}.
\protindex{all}
\index{method!creation}
\index{browser!defining a method}

\needlines{10}
%\begin{numMethod}[scbecellinitialize]{Initializing instances of \ct{LOCell}}
\begin{numMethod}[scbecellinitialize]{Инициализация переменных экземпляра \ct{LOCell}}
initialize
   super initialize.
   self label: ''.
   self borderWidth: 2.
   bounds := 0@0 corner: 16@16.
   offColor := Color paleYellow.
   onColor := Color paleBlue darker.
   self useSquareCorners.
   self turnOff
\end{numMethod}
\index{initialization}

\noindent
%Note that the characters \ct{''} on line 3 are two separate single quotes with nothing between them, not a double quote!  \ct{''} denotes the empty string.
Заметьте, что знак \ct{''} в третьей строке --- это две, идущие подряд, одинарные кавычки, а не двойная кавычка! \ct{''} означает пустую строку.

%\dothis{\menu{Accept} this method definition.}
\dothis{Примите (\menu{Accept}) это определение метода.}

%What does the above code do?  We won't go into all of the details here (that's what the rest of the book is for!), but we will give you a quick preview.  Let's take it line by line.
Что же делает этот код? Мы не будем вдаваться во все подробности (этим мы займёмся в остальной части книги!), а вместо этого сделаем небольшой обзор, пройдясь по коду строка за строкой.

%Notice that the method is called \mthind{LOCell}{initialize}.
Обратите внимание, метод называется \mthind{LOCell}{initialize}.
%The name is very significant!
Это очень важно!
%By convention, if a class defines a method named \ct{initialize}, it will be called right after the object is created.
По соглашению, если класс определяет метод \ct{initialize}, он будет вызван сразу после создания объекта.
%So, when we evaluate \ct{LOCell new}, the message \ct{initialize} will be sent automatically to this newly created object.
Поэтому, когда мы выполняем \ct{LOCell new}, сообщение \ct{initialize} будет послано автоматически вновь созданному объекту.
%Initialize methods are used to set up the state of objects, typically to set their instance variables; this is exactly what we are doing here.
Методы инициализации используются для задания начального состояния объекта, в частности его переменных экземпляра. Так мы и поступаем в нашем примере.
\seeindex{Object!initialization}{initialization}
\index{initialization}

%The first thing that this method does (line 2) is to execute the \ct{initialize} method of its superclass, \ct{SimpleSwitchMorph}.
Первое, что делает этот метод (вторая строка), --- это выполнение метода \ct{initialize} суперкласса \ct{SimpleSwitchMorph}.
%The idea here is that any inherited state will be properly initialized by the \ct{initialize} method of the superclass.
Идея здесь заключается в том, что любое унаследованное состояние должно быть правильно проинициализировано с помощью метода \ct{initialize} суперкласса.
%It is always a good idea to initialize inherited state by sending \ct{super initialize} before doing anything else; we don't know exactly what \ct{SimpleSwitchMorph}'s \ct{initialize} method will do, and we don't care, but it's a fair bet that it will set up some instance variables to hold reasonable default values, so we had better call it, or we risk starting in an unclean state.
Это хорошая идея, инициализировать унаследованное состояние, посылая \ct{super initialize} перед тем, как сделать что-либо ещё. Мы не знаем точно, что будет делать метод \ct{initialize} класса \ct{SimpleSwitchMorph}, и нас это мало интересует. Главное, что он присвоит некоторым переменным экземпляра осмысленные значения по-умолчанию. Поэтому мы и должны его вызвать, а иначе рискуем начать работу в несогласованном состоянии.

%The rest of the method sets up the state of this object.
Остаток метода инициализирует состояние вновь созданного объекта.
%Sending \ct{self label: ''}, for example, sets the label of this object to the empty string.
Посылка \ct{self label: ''}, например, установит метку этого объекта равной пустой строке.
\pvindex{self}

%The expression \ct{0@0 corner: 16@16} probably needs some explanation. 
Выражение \ct{0@0 corner: 16@16}, вероятно, нуждается в некоторых пояснениях.
%\lct{0@0} represents a \clsind{Point} object with $x$ and $y$ coordinates both set to 0.
\lct{0@0} представляет собой экземпляр класса \clsind{Point} (точка) с координатами $x$ и $y$ равными нулю.
%In fact, \ct{0@0} sends the message \ct{@}
Фактически, \ct{0@0} посылает сообщение \ct{@}
% Yuck... the following should be \mthind{Number}{@} 
%%% THIS IS BROKEN -- don't do it! (on)
%\def\atsign{\textsf{@}}%
%{\makeatletter
%	\protected@write\@indexfile{}%
%    {\string\indexentry{\string\atsign|see{Number, \string\atsign}}{\thepage}}%
%	\protected@write\@indexfile{}%
%    {\string\indexentry{Number!\string\atsign|hyperpage}{\thepage}}%
%	\makeatother}
%to the number \ct{0} with argument \ct{0}.
числу \ct{0} с аргументом \ct{0}.
%The effect will be that the number \ct{0} will ask the \ct{Point} class to create a new instance with coordinates (0,0).
Результатом этого станет то, что число \ct{0} <<попросит>> класс \ct{Point} создать новый экземпляр с координатами (0,0).
%Now we send this newly created point the message \ct{corner: 16@16}, which causes it to create a \clsind{Rectangle} with corners \ct{0@0} and \ct{16@16}.
Затем мы посылаем созданному объекту-точке сообщение \ct{corner: 16@16}, получая таким образом прямоугольник (\clsind{Rectangle}) с углами \ct{0@0} и \ct{16@16}.
%This newly created rectangle will be assigned to the \ct{bounds} variable, inherited from the superclass.
Этот прямоугольник будет присвоен переменной \ct{bounds}, унаследованной от суперкласса.

%Note that the origin of the \pharo screen is the \emph{top left}, and the $y$ coordinate increases \emph{downwards}.
Имейте ввиду, что начало координат экрана в \pharo --- это \emph{верхний левый угол} и координата $y$ увеличивается \emph{сверху вниз}.

%The rest of the method should be self-explanatory.
Остаток метода вполне самоочевиден.
%Part of the art of writing good \st code is to pick good method names so that \st code can be read like a kind of pidgin English.
Одной из составляющих искусства написания качественного \st кода является выбор хороших имён методов, так чтобы код можно было читать словно некий гибридный вариант английского.
%You should be able to imagine the object talking to itself and saying ``\ct{Self use square corners!}'', ``\ct{Self turn off!}''.
Просто попробуйте вообразить объект, говорящий себе <<Я должен использовать острые углы! \ct{Self use square corners!}>>, <<Я должен выключиться! \ct{Self turn off!}>>.

%=================================================================
%\section{Inspecting an object}
\section{Инспектирование объекта}

%You can test the effect of the code you have written by creating a new \ct{LOCell} object and inspecting it.
Вы можете посмотреть на результат кода, который только что написали, создав новый объект \ct{LOCell} и проинспектировав его.

%\dothis{Open a workspace. Type the expression \ct{LOCell new} and \menu{inspect it}.}
\dothis{Откройте окно рабочей области. Введите выражение \ct{LOCell new} и выберите пункт меню \menu{inspect it}.}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=\textwidth]{LOCellInspector} 
   %\caption{The inspector used to examine a LOCell object.\figlabel{LOCellInspector}}
   \caption{Инспектор, используемый для исследования объекта класса LOCell.\figlabel{LOCellInspector}}
\end{figure}

%The left-hand pane of the \ind{inspector} shows a list of instance variables; if you select one (try \mbox{\ct{bounds}),} the value of the \ind{instance variable} is shown in the right pane.
Левая панель \ind{инспектора} отображает список переменных экземпляра. Если вы выберете одну из них (попробуйте \mbox{\ct{bounds}),} значение \ind{переменной экземпляра} отобразится на правой панели.

%  You can also use the inspector to change the value of an instance variable.
%\dothis{Change the value of \ct{bounds} to \ct{0@0 corner: 50@50} and \menu{accept} it.}
%\on{This does not work any more. I get:}
%\ct{OTNamedVariableNode(Object)>>doesNotUnderstand: #selectedClass}
%\on{should use the mini workspace instead to send bounds: ?}

%The bottom pane of the inspector is a mini-workspace.  It's useful because in this workspace the pseudo-variable \self is bound to the object selected. 
Нижняя панель инспектора представляет собой небольшую рабочую область. Это удобно, поскольку здесь псевдопеременная \self связывается с выбранным в данный момент объектом.

\dothis{
%Select the LOCell at the root of the inspector window.
Выберите LOCell в корне окна инспектора.
%Type the text \ct{self bounds: (200@200 corner: 250@250)} in the bottom pane and \menu{do it}. The \ct{bounds} variable should change in the inspector.
Введите текст \ct{self bounds: (200@200 corner: 250@250)} в нижней панели и выполните (\menu{do it}) его. Переменная \ct{bounds} в инспекторе должна измениться.
%Now type the text \ct{self openInWorld} in the mini-workspace and \menu{do it}.}
Теперь введите текст \ct{self openInWorld} в этой малой рабочей области и выполните его тоже.
%The cell should appear near the top left-hand corner of the screen, indeed, exactly where its \ct{bounds} say that it should appear.
Ячейка должна появиться вблизи верхнего левого угла экрана, где ей и велят находиться её границы (\ct{bounds}).
%\metaclick on the cell to bring up the morphic \subind{Morphic}{halo}.
\metaclick на ячейке, чтобы появилось гало (\subind{Morphic}{halo}).
%Move the cell with the brown (next to top-right) handle and resize it with the yellow (bottom-right) handle.
Передвиньте ячейку с помощью коричневой кнопки (возле верхнего правого угла) и измените её размер с помощью жёлтой кнопки (справа снизу).
%Notice how the bounds reported by the inspector also change.
Обратите внимание на то, что границы, отображаемые в инспекторе также меняются.
%(You may have to \actclick{} \menu{refresh} to see the new bounds value.)
(Вам может понадобится выбрать в меню (\actclick{}) команду \menu{refresh}, чтобы обновить значение границ.)

\begin{figure}[htbp]
\centering
\ifluluelse
	{\includegraphics[width=\textwidth]{LOCellResize} }
	{\includegraphics[scale=0.7]{LOCellResize} }
%\caption{Resizing the cell.\figlabel{cellresize}}
\caption{Изменение размеров ячейки.\figlabel{cellresize}}
\end{figure}

%\dothis{Delete the cell by clicking on the \ct{x} in the pink handle.}
\dothis{Удалите ячейку, кликнув на \ct{x} (розовая кнопка).}

%=================================================================
%\section{Defining the class LOGame}
\section{Создание класса LOGame}

%Now let's create the other class that we need for the game, which we will call \clsind{LOGame}.
Теперь давайте создадим класс, который будет представлять игру, и назовём его \clsind{LOGame}.

%\dothis{Make the class definition template visible in the browser main window.}
\dothis{Перейдите к шаблону определения класса в браузере.}
%Do this by clicking on the package name.
Для этого кликните на имени пакета.
%Edit the code so that it reads as follows, and \menu{accept} it.
Теперь отредактируйте код как показано ниже и примите его.

\needlines{6}
%\begin{classdef}[sbegame]{Defining the \ct{LOGame} class}
\begin{classdef}[sbegame]{Определение класса \ct{LOGame}}
BorderedMorph subclass: #LOGame
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PBE-LightsOut'
\end{classdef}

%Here we subclass \clsind{BorderedMorph}; \clsind{Morph} is the superclass of all of the graphical shapes in \pharo, and (surprise!) a \ct{BorderedMorph} is a \ct{Morph} with a border.  
Мы наследуемся от класса \clsind{BorderedMorph}. \clsind{Morph} (Морф) --- это базовый класс всех графических объектов в \pharo, а \ct{BorderedMorph} --- это морф с рамкой.
%We could also insert the names of the instance variables between the quotes on the second line, but for now, let's just leave that list empty.
Мы можем вставить имена переменных экземпляра между кавычек во второй строке, но пока давайте оставим всё без изменений.

%Now let's define an \mthind{LOGame}{initialize} method for \ct{LOGame}.
Теперь перейдём к определнию метода \mthind{LOGame}{initialize} класса \ct{LOGame}.

%\dothis{Type the following into the browser as a method for \ct{LOGame} and try to \menu{accept} it:}
\dothis{Введите следующий код метода \ct{LOGame} в окно браузера и попробуйте принять его:}

%\begin{numMethod}[sbegameinitialize]{Initializing the game}
\begin{numMethod}[sbegameinitialize]{Инициализируем игру}
initialize
   | sampleCell width height n |
   super initialize.
   n := self cellsPerSide.
   sampleCell := LOCell new.
   width := sampleCell width.
   height := sampleCell height.
   self bounds: (5@5 extent: ((width*n) @(height*n)) + (2 * self borderWidth)).
   cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ].
\end{numMethod}

%\sd{it would be nicer if we would not have to create an instance of LOCell for nothing}
%\on{yes}

%\pharo will complain that it doesn't know the meaning of some of the terms.
\pharo пожалуется на то, что ему незнакомо значение некоторых терминов.
%\pharo tells you that it doesn't know of a message \ct{cellsPerSide}, and suggests a number of corrections, in case it was a spelling mistake.
\pharo предупредит, что ничего не знает о сообщении \ct{cellsPerSide} и предоставит на выбор несколько подходящих вариантов исправления, как в случае, если бы это слово было бы написано с ошибкой.


\begin{figure}[htb]
\begin{minipage}{0.48\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{UnknownSelector}}
		{\includegraphics[scale=0.7]{UnknownSelector}}
	%\caption{\pharo detecting an unknown selector.\figlabel{unknownSelector}}
	\caption{\pharo определяет неизвестный селектор.\figlabel{unknownSelector}}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\centering
	\ifluluelse
		{\includegraphics[width=\textwidth]{DeclareInstanceVar}}
		{\includegraphics[scale=0.7]{DeclareInstanceVar}}
	%\caption{Declaring a new instance variable.\figlabel{declareInstance}}
	\caption{Определение новой переменной экземпляра.\figlabel{declareInstance}}
\end{minipage}
\end{figure}

%But \ct{cellsPerSide} is not a mistake\,---\,it is just a method that we haven't yet defined\,---\,we will do so in a minute or two.
Но \ct{cellsPerSide} --- это не ошибка, а метод, который мы ещё не определили, но обязательно сделаем это через пару минут.

%\dothis{So just select the first item from the menu, which confirms that we really meant \ct{cellsPerSide}.}
\dothis{Просто выберите первый пункт в меню, подтвердив таким образом, что мы действительно имели в виду \ct{cellsPerSide}.}

%Next, \pharo will complain that it doesn't know the meaning of \ct{cells}.  It offers you a number of ways of fixing this.
Далее \pharo пожалуется, что ему незнакомо имя \ct{cells}, и предложит несколько вариантов его исправления.

%\dothis{Choose \menu{declare instance} because we want \ct{cells} to be an instance variable.}
\dothis{Выберите пункт меню \menu{declare instance}, т.к. мы хотим определить переменную экземпляра \ct{cells}.}
%Finally, \pharo will complain about the message \ct{newCellAt:at:} sent on the last line; this is also not a mistake, so confirm that message too.
Наконец, \pharo предупредит вас о сообщении \ct{newCellAt:at:}, посылаемом в последней строке. Это тоже не ошибка, поэтому подтвердите и это сообщение.
\index{on the fly variable definition}
\index{instance variable definition} 

%If you now look at the class definition once again (which you can do by clicking on the \button{instance} button), you will see that the browser has modified it to include the instance variable \ct{cells}.
Теперь, если вы снова посмотрите на определение класса, кликнув по кнопке \button{instance} (экземпляр), вы увидите, что браузер его модифицировал, добавив определение переменной \ct{cells} (ячейки).

%Let's look at this \ct{initialize} method.
Посмотрим же на метод \ct{initialize} повнимательнее.
%The line \ct{| sampleCell width height n |}  declares 4 temporary variables. They are called temporary variables because their scope and lifetime are limited to this method.  Temporary variables with explanatory names are helpful in making code more readable.  Smalltalk has no special syntax to distinguish constants and variables, and in fact all four of these ``variables'' are really constants. 
Строка \ct{| sampleCell width height n |} определяет четыре вр'еменных переменных. Они называются временными, потому что их область видимости и время жизни ограничены методом, в котором они определены. Временные переменные с понятными, поясняющими именами всегда помогают сделать код более легкочитаемым. В \st не предусмотрен отличающийся синтаксис для констант и переменных, но все четыре упомянутые переменные являются константами.
%Lines 4--7 define these constants.
Строки с четвёртой по седьмую определяют эти константы.

%How big should our game board be?  Big enough to hold some integral number of cells, and big enough to draw a border around them.
Насколько большим должно быть поле для игры? Достаточно большим, чтобы вмещать в себя целое число ячеек, и достаточно большим, чтобы иметь возможность нарисовать рамку вокруг них.
%How many cells is the right number?  5? 10? 100? We don't know yet, and if we did, we would probably change our minds later.  So we delegate the responsibility for knowing that number to another method, which we will call \ct{cellsPerSide}, and which we will write in a minute or two.
Сколько ячеек будет достаточно? Пять? Десять? Сто? Пока мы этого не знаем, а если бы даже и знали, то позже могли бы изменить своё мнение. Поэтому мы делегируем ответственность за это методу определяющему количество ячеек, приходящихся на одну сторону поля. Назовём этот метод \ct{cellsPerSide}, а реализацию его рассмотрим чуть позже.
%It's because we are sending the \ct{cellsPerSide} message before we define a method with that name that \pharo asked us to ``confirm, correct, or cancel'' when we accepted the method body for \ct{initialize}.
Вот почему \pahro просил нас <<подтвердить, исправить или отменить>> (<<confirm, correct or cancel>>), когда мы приняли тело метода \ct{initialize}: мы посылали сообщение \ct{cellsPerSide}, но метода с таким именем ещё не существовало.
%Don't be put off by this: it is actually good practice to write in terms of other methods that we haven't yet defined.
Не пугайтесь --- это нормальная практика, писать код в терминах методов, которые ещё не были определены.
%Why?  Well, it wasn't until we started writing the \ct{initialize} method that we realized that we needed it, and at that point, we can give it a meaningful name, and move on, without interrupting our flow.
Почему? Просто, когда мы начинали писать метод \ct{initialize} мы не знали, что этот метод может нам понадобиться. Но в то же время мы могли дать ему осмысленное имя и продолжить, не прерывая работы над текущим методом.
 
%The fourth line uses this method: 
Четвёртая строка использует этот метод:
%the Smalltalk \ct{self cellsPerSide} sends the message \ct{cellsPerSide} to \pvind{self}, i.e., to this very object.  
выражение \ct{self cellsPerSide} посылает сообщение \ct{cellsPerSide} объекту \pvind{self}, т.е. этому самому объекту.
%The response, which will be the number of cells per side of the game board, is assigned to \ct{n}.
Результат выражения, обозначающий количество ячеек, приходящихся на одну сторону игрового поля, присваивается переменной \ct{n}.

%The next three lines create a new \ct{LOCell} object, and assign its width and height to the appropriate temporary variables. 

%The eighth line sends the message \ct{bounds:} to \self.
%\ct{bounds:} is a method that we inherit from our superclass; it is used to define the space on the screen that this Morph will occupy.  
%The single colon (\ct{:}) at the end of the name says that \ct{bounds:} expects a single parameter, which should be a rectangle object.
%Line 8 sets the \ct{bounds} of the new object.
Восьмая строка устанавливает границы (\ct{bounds}) нового объекта.
%Without worrying too much about the details just yet, just believe us that the expression in parentheses creates a square with its origin (\ie its top-left corner) at the point (5,5) and its bottom-right corner far enough away to allow space for the right number of cells.
Не беспокоясь здесь о деталях, просто знайте, что выражение в скобках, создаёт квадрат с началом координат (т.е. верхним левым углом) в точке (5, 5) и правым нижним углом, достаточно удалённым от него, чтобы вместить нужное количество ячеек.

%The last line sets the \ct{LOGame} object's instance variable \ct{cells} to a newly created \clsind{Matrix} with the right number of rows and columns.   We do this by sending the message \ct{new:tabulate:} to the \ct{Matrix} class (classes are objects too, so we can send them messages).  We know that \mthind{Matrix class}{new:tabulate:} takes two arguments because it has two colons (\ct{:}) in its name.   The arguments go right after the colons.
Последняя строка присваивает переменной \ct{cells} класса \ct{LOGame} вновь созданную матрицу (объект класса \clsind{Matrix}) с нужным количеством строк и столбцов. Мы делаем это с помощью сообщения \ct{new:tabulate:} посылаемого классу \ct{Matrix} (классы ведь тоже объекты и мы можем точно так же посылать им сообщения). Мы знаем, что \mthind{Matrix class}{new:tabulate:} принимает два аргумента, потому что в его имени присутствуют два двоеточия (\ct{:}), а аргументы при посылке указываются прямо за ними.
%If you are used to languages that put all of the arguments together inside parentheses, this may seem weird at first.  Don't panic, it's only syntax!
Если вы привыкли к языкам, которые сваливают все аргументы в кучу, огороженную скобками, это может сперва показаться странным. Но не паникуйте,
%It turns out to be a very good syntax because the name of the method can be used to explain the roles of the arguments.  For example, it is pretty clear that \ct{Matrix rows: 5 columns: 2} has 5 rows and 2 columns, and not 2 rows and 5 columns.
вскоре вам это синтаксическое решение покажется очень хорошим, т.к. имя метода может пояснить роли его аргументов. Например, моментально становится ясно, что \ct{Matrix rows: 5 columns: 2} имеет пять строк и два столбца, а не наоборот.
\cmindex{Matrix class}{rows:columns:}

%\ct{Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]} creates a new \ct{n}{$\times$}\ct{n} matrix and initializes its elements.  The initial value of each element will depend on its coordinates.  The \ct{(i,j)}\textsuperscript{th} element will be initialized to the result of evaluating \ct{self newCellAt: i at: j}.  
\ct{Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]} создаёт новую матрицу \ct{n}{$\times$}\ct{n} и инициализирует её элементы. Начальное значение каждого элемента будет зависеть от его координат. \ct{(i,j)}\textsuperscript{й} элемент будет инициализирован результатом вычисления \ct{self newCellAt: i at: j}.

%:===> Pretty-print is broken! (how to pretty-print?)

% \on{I think it is silly to copy paste from the pretty-print view to the normal view}

%That's \ct{initialize}.  When you accept this message body, you might want to take the opportunity to pretty-up the formatting.  You don't have to do this by hand: from the \actclick menu select \menu{more \ldots \go prettyprint}, and the browser will do it for you\damien{this didn't do anything to me}.  You have to \menu{accept} again after you have \subind{method}{pretty-print}{}ed a method, or of course you can \subind{keyboard shortcut}{cancel} 
%(\short{l}\,---\,that's a lower-case letter \emph{L}) if you don't like the result.
%Alternatively, you can set up the browser to use the pretty-printer automatically whenever it shows you code: use the the right-most button in the button bar to adjust the view.
%\seeindex{pretty-print}{method}

%If you find yourself using \menu{more\,\ldots} a lot, it's useful to know that you can hold down the {\sc shift} key when you click to directly bring up the \menu{more \ldots} menu.

%=================================================================
%\section{Organizing methods into protocols}
\section{Объединение методов в протоколы}

%Before we define any more methods, let's take a quick look at the third pane at the top of the browser.
Перед тем, как мы определим ещё методы, давайте взглянем на третью слева панель в верхней части браузера.
%In the same way that the first pane of the browser lets us categorize classes into packages so we are not overwhelmed by a very long list of class names in the second pane, so the third pane lets us categorize methods so that we are not overwhelmed by a very long list of method names in the fourth pane.   
Точно так же, как первая панель браузера позволяет нам организовать классы в пакеты, так, чтобы мы не оказались один на один с бесконечно длинным списком имён классов во второй панели, третья панель позволяет категоризировать методы, так что нам не придётся столкнуться с длинным списком имён методов в четвёртой панели.
%These categories of methods are called ``protocols''.
Категории методов называются <<протоколы>> (protocols).
\index{protocol}

%If there are only a few methods in a class, the extra level of hierarchy provided by protocols is not really necessary.
Если класс содержит всего несколько методов, дополнительный уровень иерархии, предоставляемый протоколами отнюдь не обязателен.
%This is why the browser also offers us the \prot{-{}-all-{}-} virtual protocol, which, you will not be surprised to learn, contains all of the methods in the class.
Вот почему браузер позволяет использовать виртуальный протокол \prot{-{}-all-{}-}, который содержит все методы класса.
\protindex{all}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=\textwidth]{Categorize} 
   %\caption{Automatically categorize all uncategorized methods.\figlabel{categorize}}
   \caption{Автоматическая категоризация всех методов, не относящихся к какой-либо категории}
\end{figure}

%If you have followed along with this example, the third pane may well contain the protocol \protind{as yet unclassified}.
Если вы всё это время точно следовали нашим действиям, третья панель в вашем браузере должна содержить протокол \protind{as yet unclassified} (<<ещё не классифицированы>>).

%\dothis{\Actclick in the protocol pane and select \menu{various \go categorize automatically} to fix this, and move the \ct{initialize} methods to a new protocol called \protind{initialization}.}
\dothis{Сделайте \Actclick на панели протоколов и выберите пункт меню \menu{various \go categorize automatically} (категоризировать автоматически) чтобы исправить это, поместив метод \ct{initialize} в новый протокол \protind{initialization}.}
%How does \pharo{} know that this is the right protocol?  Well, in general \pharo{} can't know, but in this case there is also an \ct{initialize} method in a superclass, and \pharo assumes that our \ct{initialize} method should go in the same category as the one that it overrides.
Как \pharo узнаёт, что это именно тот протокол, который нам нужен? Конечно, \pharo не может этого знать, но в данном случае, в суперклассе уже определён метод \ct{initialize}, и \pharo предполагает, что наш метод \ct{initialize} должен находиться в той же категории, что и тот, который он переопределяет.
\index{method!categorize}

%You may find that \pharo has already put your \ct{initialize} method into the \protind{initialization} protocol.
%If so, it's probably because you have loaded a package called \ct{AutomaticMethodCategorizer} into your image.

%\paragraph{A typographic convention.} Smalltalkers frequently use the notation ``\verb|>>|'' to identify the class to which a method belongs, so, for example, the \ct{cellsPerSide} method in class \ct{LOGame} would be referred to as \ct{LOGame>>cellsPerSide}.
\paragraph{Типографское соглашение.} Программисты на \st часто используют нотацию `\verb|>>|'', чтобы обозначать класс, которому принадлежит метод. Так, например, на метод \ct{cellsPerSide} в классе \ct{LOGame} будут ссылаться как на \ct{LOGame>>cellsPerSide}.
%To indicate that this is \emph{not} \st syntax, we will use the special symbol \ct{>>>} instead, so this method will appear in the text as \ct{LOGame>>>cellsPerSide}
Чтобы показать, что это \emph{не} \st синтаксис, мы будем использовать специальный символ \ct{>>>}, и ссылка на этот метод будет выглядеть в тексте как \ct{LOGame>>>cellsPerSide}.
\cmindex{Behavior}{>>}

%From now on, when we show a method in this book, we will write the name of the method in this form.  Of course, when you actually type the code into the browser, you don't have to type the class name or the \ct{>>>}; instead, you just make sure that the appropriate class is selected in the class pane.  
С этого момента, когда мы захотим сослаться на метод в книге, мы будем писать его имя именно в этой форме. Разумеется, когда вы вводите код в браузере, вам не нужно набирать имя класса или \ct{>>>}. Вместо этого, просто убедитесь, что нужный клас выбран на панели классов.

%Now let's define the other two methods that are used by the \ct{LOGame>>>initialize} method. Both of them can go in the \prot{initialization} protocol.
Давайте теперь определим остальные два метода, использумых в методе \ct{LOGame>>>initialize}. Оба они будут относиться к протоколу \prot{initialization}.

%\begin{method}[sbegamecellsperside]{A constant method.}
\begin{method}[sbegamecellsperside]{Метод-константа.}
LOGame>>>cellsPerSide
   "Количество ячеек, приходящееся на одну сторону игрового поля"
   ^ 10
\end{method}
\cmindex{LOGame}{cellsPerSide}
\index{constant methods}

%This method could hardly be simpler: it answers the constant 10.  One advantage of representing constants as methods is that if the program evolves so that the constant then depends on some other features, the method can be changed to calculate this value.
Вряд ли этот метод можно сделать ещё проще: он всего лишь возвращает константу <<10>>. Преимущество представления констант с помощью методов заключается в том, что если программа эволюционирует, константа может начать зависеть от других свойств системы, поэтому метод может измениться, чтобы вычислять значение.

\needlines{10}
%\begin{method}[newCellAt:at:]{An initialization helper method}
\begin{method}[newCellAt:at:]{Вспомогательный метод для инициализации}
LOGame>>>newCellAt: i at: j
   "Создаёт ячейку в позиции (i,j) и добавляет её на экран. Возвращает новую ячейку."
   | c origin |
   c := LOCell new.
   origin := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
   c mouseAction: [self toggleNeighboursOfCellAt: i at: j]
\end{method}
\cmindex{LOGame}{newCellAt:at:}
%   ^ c      "omit this final line to create a bug"

%\dothis{Add the methods \ct{LOGame>>>cellsPerSide} and \ct{LOGame>>>newCellAt:at:}.}
\dothis{Добавьте методы \ct{LOGame>>>cellsPerSide} и \ct{LOGame>>>newCellAt:at:}.}
%Confirm the spelling of the new selectors \ct{toggleNeighboursOfCellAt:at:} and \ct{mouseAction:}.
Подтвердите правильность написания селекторов \ct{toggleNeighboursOfCellAt:at:} и \ct{mouseAction:}.

%\Mthref{newCellAt:at:} answers a new LOCell, specialized to position \ct{(i, j)} in the \clsind{Matrix} of cells.
\Mthref{newCellAt:at:} возвращает новый экземпляр LOCell, предназначенный для позиции \ct{(i, j)} в матрице ячеек (класс \clsind{Matrix}).
%The last line defines the new cell's \ct{mouseAction} to be the \emph{block}
Последняя строка определяет свойство \ct{mouseAction} новой ячейки. Как видите --- это блок.
\mbox{\lct{[self toggleNeighboursOfCellAt: i at: j ]}.}
% In effect, this defines the callback behaviour to perform when the mouse is clicked.
 В сущности, это определяет поведение при обратном вызове, который произойдёт при клике мышью.
%The corresponding method also needs to be defined.
Соответствующий метод также должен быть определён.

%\begin{method}[toggleNeighboursOfCellAt:at:]{The callback method}
\begin{method}[toggleNeighboursOfCellAt:at:]{Метод обратного вызова}
LOGame>>>toggleNeighboursOfCellAt: i at: j
   (i > 1) ifTrue: [ (cells at: i - 1 at: j ) toggleState].
   (i < self cellsPerSide) ifTrue: [ (cells at: i + 1 at: j) toggleState].
   (j > 1) ifTrue: [ (cells at: i  at: j - 1) toggleState].
   (j < self cellsPerSide) ifTrue: [ (cells at: i at: j + 1) toggleState].
\end{method}
\cmindex{LOGame}{toggleNeighboursOfCellAt:at:}

%\Mthref{toggleNeighboursOfCellAt:at:} toggles the state of the four cells to the north, south, west and east of cell (\ct{i}, \ct{j}).  The only complication is that the board is finite, so we have to make sure that a neighboring cell exists before we toggle its state.
\Mthref{toggleNeighboursOfCellAt:at:} переключает состояние четырёх ячеек с северной, южной, западной и восточной сторон ячейки (\ct{i}, \ct{j}). Единственная сложность заключается в том, что игровое поле конечно, и поэтому нам придётся проверять, что соседние ячейки существуют, перед тем, как мы изменим их состояние.

%\dothis{Place this method in a new protocol called \prot{game logic}. (\Actclick in the protocol pane to add a new protocol.)}
\dothis{Разместите метод в новм протоколе \prot{game logic} (игровая логика). (Чтобы добавить новый протокол, сделайте \Actclick на панели протоколов.)}
%To move the method, you can simply click on its name and drag it to the newly-created protocol (\figref{dragMethod}).
Чтобы переместить метод, вы можете просто кликнуть на его имени и перетащить во вновь созданный протокол (\figref{dragMethod}).

\begin{figure}[htbp]
   \centering
   \ifluluelse
		{\includegraphics[width=\textwidth]{DragMethod} }
		{\includegraphics[scale=0.7]{DragMethod} }
   %\caption{Drag a method to a protocol.\figlabel{dragMethod}}
   \caption{Перемещение метода в протокол.\figlabel{dragMethod}}
\end{figure}

%To complete the Lights Out game, we need to define two more methods in class \ct{LOCell} to handle mouse events.
Чтобы закончить игру Lights Out, нам нужно определить ещё два метода для обработки событий мыши в классе \ct{LOCell}.
%\begin{method}[mouseAction:]{A typical setter method}
\begin{method}[mouseAction:]{Типичный метод, устанавливающий значение}
LOCell>>>mouseAction: aBlock
   ^ mouseAction := aBlock
\end{method}
\cmindex{LOCell}{mouseAction:}

%\Mthref{mouseAction:} does nothing more than set the cell's \ct{mouseAction} variable to the argument, and then answers the new value.
\Mthref{mouseAction:} всего лишь устанавливает значение переменной ячейки \ct{mouseAction} равным переданному аргументу и возвращает её новое значение.
%Any method that \emph{changes} the value of an instance variable in this way is called a \emph{setter method}; a method that \emph{answers} the current value of an instance variable is called a \emph{getter method}.
Любой метод, который \emph{изменяет} значение переменной экземпляра описанным способом называется \emph{метод установки значения} (setter method). Метод, который \emph{возвращает} текущее значение переменной называется \emph{метод получения значения} (getter method).
\seeindex{setter method}{accessor}
\seeindex{getter method}{accessor}

%If you are used to getters and setters in other programming languages, you might expect these methods to be called \ct{setmouseAction} and \ct{getmouseAction}.
Если вы привыкли к подобным методам в других языках программирования, вы можете ожидать, что они будут называться \ct{setMouseAction} и \ct{getМouseAction}.
%The \st convention is different.
В \st принято другое соглашение.
%A getter always has the same name as the variable it gets, and a setter is named similarly, but with a trailing ``\ct{:}'', hence \ct{mouseAction} and \ct{mouseAction:}.
Метод получения всегда называется также, как и переменная, значение которой он возвращает. Имя метода установки тоже совпадает с именем переменной, но оканчивается двоеточием (\ct{:}). То есть у нас получаются \ct{mouseAction} и \ct{mouseAction:}.

%Collectively, setters and getters are called  \emphind{accessor} methods, and by convention they should be placed in the \protind{accessing} protocol.
В совокупности методы установки и получения значения называются \emph{методами доступа}, и по соглашению должны располагаться в протоколе \protind{accessing}.
%In Smalltalk, \emph{all} instance variables are private to the object that owns them, so the only way for another object to read or write those variables in the Smalltalk language is through accessor methods like this one\footnote{In fact, the instance variables can be accessed in subclasses too.}.
В \st \emph{все} переменные экземпляра приватные по отношению к объекту-владельцу. Поэтому единственный способ в \st, с помощью которого другой объект может прочитать или записать значение этих переменных, --- это использование методов доступа\footnote{На самом деле, переменные экземпляра доступны и в подклассах.}.

%\dothis{Go to the class \ct{LOCell}, define \ct{LOCell>>>mouseAction:} and put it in the \prot{accessing} protocol.}
\dothis{Перейдите к классу \ct{LOCell}, определите метод \ct{LOCell>>>mouseAction:} и поместите его в протокол \prot{accessing}.}

%Finally, we need to define a method \ct{mouseUp:}; this will be called automatically by the GUI framework if the mouse button is released while the mouse is over this cell on the screen.
Наконец, мы должны определить метод \ct{mouseUp:}, который будет вызван автоматически графическим фреймворком, если кнопка мыши будет отпущена пока указатель находится над данной ячейкой.

%\begin{method}[sbecellmouseup]{An event handler}
\begin{method}[sbecellmouseup]{Обработчик события}
LOCell>>>mouseUp: anEvent
   mouseAction value
\end{method}
\cmindex{LOCell}{mouseUp:}

%\dothis{Add the method \ct{LOCell>>>mouseUp:} and then
\dothis{Добавьте метод \ct{LOCell>>>mouseUp:} и 
  категоризируйте методы автоматически (пункт меню \menu{categorize automatically}).}
\index{method!categorize}

%What this method does is to send the message \ct{value} to the object stored in the instance variable \ct{mouseAction}. 
Всё, что делает этот метод --- это посылает сообщение \ct{value} объекту, хранящемуся в переменной экземпляра \ct{mouseAction}. 
%Recall that in \ct{LOGame>>>newCellAt: i at: j} we assigned the following code fragment to \ct{mouseAction}:
Напомним, что в методе \ct{LOGame>>>newCellAt: i at: j} мы присвоили следующий фрагмент кода переменной \ct{mouseAction}:

\ct{[self toggleNeighboursOfCellAt: i at: j ]} 

\noindent
%Sending the \ct{value} message causes this code fragment to be evaluated, and consequently the state of the cells will toggle.
Посылка сообщения \ct{value} приводит к тому, что этот фрагмент кода будет выполнен и, как следствие, изменится состояние соседних ячеек.

%=================================================================
%\section{Let's try our code}
\section{Наш код в действии}

%That's it: the Lights Out game is complete!
Вот и всё, игра Lights Out закончена!

%If you have followed all of the steps, you should be able to play the game, consisting of just 2 classes and 7 methods.
Если вы последовательно выполняли все шаги, то сейчас вы можете запустить нашу игру, состояющую всего из двух классов и семи методов.

%\dothis{In a workspace, type \ct{LOGame new openInWorld} and \menu{do it}.}
\dothis{В рабочей области введите \ct{LOGame new openInWorld} и выполните (\menu{do it}).}

%The game will open, and you should be able to click on the cells and see how it works.
Когда откроется окно игры, попробуйте кликнуть на какой-нибудь ячейки, чтобы проверить, как всё работает.

%Well, so much for theory\ldots{}
Итак, для теории\ldots{}
%When you click on a cell, a \emphind{notifier} window called the \clsind{PreDebugWindow}window appears with an error message!
Когда вы кликаете на ячейке, появляется окно \emphind{уведомления} (\clsind{PreDebugWindow}) сообщение об ошибке!
%As depicted in \figref{lightsOutError}, it says \ct{MessageNotUnderstood: LOGame>>>toggleState}.
Как показано на \figref{lightsOutError}, это сообщение \ct{MessageNotUnderstood: LOGame>>>toggleState}.

\begin{figure}[ht]
\ifluluelse
	{\centerline{\includegraphics[width=\textwidth]{Error}}}
	{\centerline{\includegraphics[scale=0.7]{Error}}}
%\caption{There is a bug in our game when a cell is clicked!
\caption{При клике на ячейке возникает ошибка!
\figlabel{lightsOutError}}
\end{figure}

\noindent
%What happened? To find out, let's use one of Smalltalk's more powerful tools: the \ind{debugger}.
Что же случилось? Чтобы добраться до причины, используем один из наиболее мощных инструментов в \st: \ind{отладчик} (\ind{debugger}).

%\dothis{Click on the \menu{debug} button in the notifer window.}
\dothis{Кликните на кнопке \menu{debug} в окне уведомления.}

%The debugger will appear.
Появится отладчик.
%In the upper part of the debugger window you can see the execution stack, showing all the active methods; selecting any one of them will show, in the middle pane, the Smalltalk code being executed in that method, with the part that triggered the error highlighted.
В верхней части окна отладчика вы видите стек выполнения, в котором отображены все активные методы. Выбор любого из них приведёт к тому, что в средней панели отобразится \st код этого метода, с подсвеченным участком, приведшем к ошибке.

%\dothis{Click on the line labelled
\dothis{Кликните на строке
%\ct{LOGame>>>toggleNeighboursOfCellAt:at:} (near the top).}
\ct{LOGame>>>toggleNeighboursOfCellAt:at:} (наверху стека).}
%The debugger will show you the \ind{execution context} within this method where the error occurred (\figref{debugToggle}).
Отладчкик покажет вам \ind{контекст выполнения} (\ind{execution context}) метода, внутри которого произошла ошибка (\figref{debugToggle}).

\begin{figure}[ht]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{Debugger}}}
	{\centerline {\includegraphics[scale=0.7]{Debugger}}}
%\caption{The debugger, with the method \ct{toggleNeighboursOfCell:at:}  selected.
\caption{Отладчик с выбранным методом \ct{toggleNeighboursOfCell:at:}.
\figlabel{debugToggle}}
\end{figure}

%At the bottom of the debugger are two small inspector windows.  On the left, you can inspect the object that is the receiver of the message that caused the selected method to execute, so you can look here to see the values of the instance variables.
В нижней части отладчика находятся два маленьких окна инспектора. В левом окне вы можете проинспектировать объект, являющийся получателем сообщения, приведшего к выполнению выбранного метода. С его помощью вы можете посмотреть значения его переменных экземпляра.
%On the right you can inspect an object that represents the currently executing method itself, so you can look here to see the values of the method's parameters and temporary variables.
В правом вы можете проинспектировать объект, который представляет сам выполняемый метод. Здесь вы можете посмотреть значения параметров метода и временных переменных.

%Using the debugger, you can execute code step by step, inspect objects in parameters and local variables, evaluate code just as you can in a workspace, and, most surprisingly to those used to other debuggers, change the code while it is being debugged! Some Smalltalkers program in the debugger almost all the time, rather than in the browser.  The advantage of this is that you see the method that you are writing as it will be executed, with real parameters in the actual execution context.
Используя отладчик, вы можете выполнить код шаг за шагом, наблюдая за состоянием параметров и локальных переменных, выполнять код точно так же, как вы это делаете в рабочей области. Но наиболее неожиданной для тех, кто привык к другим отладчикам, будет возможность изменять отлаживаемый код! Некоторые программисты на \st пишут код прямо в отладчике, а не в браузере. Преимущество такого подхода в том, что вы можете видеть метод, который пишете, в процессе выполнения с реальными параметрам в реальном контексте выполнения.

%In this case we can see in the first line of the top panel that the \ct{toggleState} message has been sent to an instance of \ct{LOGame}, while it should clearly have been an instance of \lct{LOCell}.
В данном случае мы можем видеть в первой строке верхней панели, что сообщение \ct{toggleState} было послано экземпляру класса \ct{LOGame}, хотя, очевидно, должно посылаться экземпляру \lct{LOCell}.
%The problem is most likely with the initialization of the \ct{cells} matrix.
Проблема, вероятно, кроется в инициализации матрицы ячеек \ct{cells}.
%Browsing the code of \cmind{LOGame}{initialize} shows that \ct{cells} is filled with the return values of \ct{newCellAt:at:}, but when we look at that method, we see that there is no return statement there!
При рассмотрении кода \cmind{LOGame}{initialize} становится понятно, что переменная \ct{cells} заполняется результатами выполнения метода \ct{newCellAt:at:}. Но посмотрите, в этом методе вообще нет оператора возврата!
%By default, a method returns \ct{self}, which in the case of \ct{newCellAt:at:} is indeed an instance of \ct{LOGame}.
По-умолчанию, метод возвращает ссылку на текущий объект (\ct{self}), который в случае \ct{newCellAt:at:} является экземпляром класса \ct{LOGame}.
\index{method!returning self}

%\dothis{Close the debugger window.
\dothis{Закройте окно отладчика.
%Add the expression ``\ct{^ c}'' to the end of the method \ct{LOGame>>>newCellAt:at:} so that it returns \ct{c}.
Добавьте выражение ``\ct{^ c}'' в конец метода \ct{LOGame>>>newCellAt:at:}, чтобы он возвращал значение переменной \ct{c}.
% It should now look as shown in \mthref{newCellAt:at:nobug}.}
%(See \mthref{newCellAt:at:nobug}.)}
(см. \mthref{newCellAt:at:nobug}.)}

% \needlines{6}
%\begin{method}[newCellAt:at:nobug]{Fixing the bug.}
\begin{method}[newCellAt:at:nobug]{Исправление ошибки.}
LOGame>>>newCellAt: i at: j
   "Создаёт ячейку в позиции (i,j) и добавляет её на экран. Возвращает новую ячейку."
   | c origin |
   c := LOCell new.
   origin := self innerBounds origin.
   self addMorph: c.
   c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
   c mouseAction: [self toggleNeighboursOfCellAt: i at: j].
   ^ c
\end{method}
\cmindex{LOGame}{newCellAt:at:}

\noindent
%Recall from \charef{quick} that the construct to \ind{return} a \subind{method}{value} from a method in Smalltalk is \ct{^}, which you obtain by typing \verb|^|.
В \charef{quick} мы рассказывали, что конструкция для \ind{возврата} \subind{метод}{значения} метода в \st --- это \ct{^}, которую вы получите, набрав \verb|^|.
% \index{^@\verb|^|}
\index{^@{$\uparrow$}|see{return}}

%Often, you can fix the code directly in the debugger window and click \menu{Proceed} to continue running the application.
Зачастую, вы можете исправить ошибку прямо в окне отладчика и нажать \menu{Proceed} (продолжить), чтобы продолжить выполнение программы.
%In our case, because the bug was in the initialization of an object, rather than in the method that failed, the easiest thing to do is to close the debugger window, destroy the running instance of the game (with the \subind{Morphic}{halo}), and create a new one.
В нашем случае, из-за того, что ошибка была в коде инициализации объекта, а не выдавшем ошибку методе, самым простым путём будет закрыть окно отладчика, уничтожить запущеный экземпляр игры (с помощью \subind{Morphic}{гало}) и создать новый.

%Indeed, even in this case it would be possible to \menu{do} \ct{self initialize} and then \menu{Proceed} the \ct{toggleNeighboursOfCellAt:at:} method.
%\ab{St\'eph, did you try this?  It seems to me that it ought to work, but when I tried it, it messed up my image.}
% ON : It messed me up too!  Better not propose this.

%\dothis{Do: \ct{LOGame new openInWorld} again.}
\dothis{Выполните \ct{LOGame new openInWorld} снова.}
%Now the game should work properly.
Теперь всё должно работать без ошибок.

%\sd{It would be good to have a word about the debugger buttons into, step.... Or to have a separate chapter, we would use the material I wrote for my turtle book, please check it.}
%\on{I think that is too much for this chapter. It will come soon enough.}

%=================================================================
%\section{Saving and sharing Smalltalk code}
\section{Хранение и совместный доступ к Smalltalk коду}
\seclabel{Monticello}

%Now that you have the Lights Out game working, you probably want to save it somewhere so that you can share it with your friends. Of course, you can save your whole \pharo image, and show off your first program by running it, but your friends probably have their own code in their images, and don't want to give that up to use your image.
Теперь, когда у вас есть работающая программа (игра Lights Out), вы, возможно, захотите сохранить её где-нибудь, чтобы иметь возможность поделиться ей с друзьями. Конечно, вы можете сохранить образ \pharo целиком, и показать свою первую программу, запустив его позже, но у ваших друзей, возможно, есть собственный код в их образах, и они из-за этого не захотят использовать ваш образ.
%What you need is a way of getting source code out of your \pharo image so that other programmers can bring it into theirs.
Что вам нужно --- так это способ извлечь исходный код из вашего образа \pharo, так что другие программисты смогли загрузить его в свои образы.

%The simplest way of doing this is by \emph{filing out} the code.  The \actclick menu in the Package pane will give you the option to \menu{various \go{} file out} the whole of package \scat{PBE-LightsOut}.
Простейший способ сделать это --- \emph{выгрузить код в файл} (file out). Сделайте \actclick на панели пакетов и воспользуйтесь опцией меню \menu{various \go{} file out} чтобы выгрузить весь пакет \scat{PBE-LightsOut}.
%The resulting file is more or less human readable, but is really intended for computers, not humans.
Полученный в результате файл более-менее человекочитаем, но на самом деле предназначен для компьютероа, а не для людей.
%You can email this file to your friends, and they can file it into their own \pharo images using the file list browser.
Вы можете отправить этот файл по электронной почте своим друзьям, которые затем могут загрузить его в свои образы \pharo через браузер файлов.
\seeindex{saving code}{categories}
\seeindex{category!filing out}{file, filing out}
\seeindex{class!filing out}{file, filing out}
\seeindex{method!filing out}{file, filing out}
\index{file!filing out}

%\dothis{\Actclick on the \scat{PBE-LightsOut} package and \menu{various \go{} file out} the contents.}
\dothis{Сделайте \Actclick на пакете \scat{PBE-LightsOut} и выгрузите его содержимое с помощью пункта меню \menu{various \go{} file out}.}
%You should now find a file called ``PBE-LightsOut.st'' in the same folder on disk where your image is saved.
Теперь вы можете обнаружить в папке с вашим образом файл PBE-LightsOut.st.
%Have a look at this file with a text editor.
Просмотрите содержимое этого файла в текстовом редакторе.

%\dothis{Open a fresh \pharo image and use the File Browser tool (\menu{Tools \ldots {\go} File Browser}) to \menu{file in} the PBE-LightsOut.st fileout.
\dothis{Откройте свежий образ \pharo и с помощью браузера файлов (File Browser) (пункт меню \menu{Tools \ldots {\go} File Browser}) загрузите (пункт меню \menu{file in}) файл PBE-LightsOut.st.

%Verify that the game now works in the new image.}
Проверьте, что игра продолжает работать и в новом образе.}
\seeindex{category!filing in}{file, filing in}
\seeindex{class!filing in}{file, filing in}
\seeindex{method!filing in}{file, filing in}
\index{file!filing in}

\begin{figure}[ht]
\centerline {\includegraphics[width=\textwidth]{FileIn}}
%\caption{Filing in \pharo source code.
\caption{Загрузка исходного кода \pharo.
\figlabel{filein}}
\end{figure}

%\subsection{Monticello packages}
\subsection{Пакеты Monticello}
%Although fileouts are a convenient way of making a snapshot of the code you have written, they are decidedly ``old school''.
Хотя выгрузка кода в файл является удобным способом сделать <<снимок>> кода, который вы только что написали, --- это определённо <<прошлый век>>.
%Just as most open-source projects find it much more convenient to maintain their code in a repository using \ind{CVS}\footnote{\url{http://www.nongnu.org/cvs}} or \ind{Subversion}\footnote{\url{http://subversion.tigris.org}},
Также, как множество других проектов с открытым кодом используют для хранения исходного кода репозитории \ind{CVS}\footnote{\url{http://www.nongnu.org/cvs}} или \ind{Subversion}\footnote{\url{http://subversion.tigris.org}},
%so \pharo programmers find it more convenient to manage their code using \ind{Monticello} packages. 
программисты в \pharo используют для управления кодом пакеты \ind{Monticello}.
%These packages are represented as files with names ending in \ct{.mcz}; they are actually zip-compressed bundles that contain the complete code of your \ind{package}.
Эти пакеты, представляют собой файлы с расширением \ct{.mcz}, и являются по сути весь код \ind{пакет}а, собранный воедино, и сжатый с помощью zip-алгоритма.

%Using the Monticello package browser, you can save packages to repositories on various types of server, including FTP and HTTP servers; you can also just write the packages to a repository in a local file system directory.
Используя браузер пакетов Monticello, вы можете сохранять пакеты в репозитории различных типов, включая FTP и HTTP сервера. Вы также можете сохранять пакеты в репозитории, расположенном в каталоге вашей локальной файловой системы.
%A copy of your package is also always cached on your local hard-disk in the \emph{package-cache} folder. 
Копия пакет всегда сохраняется в кеше на вашем жёстком диске в папке \emph{package-cache}.
%Monticello lets you save multiple versions of your program, merge versions, go back to an old version, and browse the differences between versions. 
Monticello позволяет вам хранить версии вашей программы, сливать их, откатываться к более старой версии, смотреть между ними разницу. 
%In fact, Monticello is a distributed revision control system; this means it allows developers to save their work on different places, not on a single repository as it is the case with CVS or Subversion.\damien{Mercurial, Git are examples of distributed revision control system; not sure it's worth mentioning them.}
Фактически, Monticello --- это распределённая система управления версиями. Это означает, что разработчики могут хранить свою работу в разных местах, а не в едином репозитории, как в случае с CVS или Subversion.
\seeindex{package browser}{Monticello}

%You can also send a \ct{.mcz} file by email. 
Можно даже отправить файл \ct{.mcz} по электронной почте.
%The recipient will have to place it in her \emph{package-cache} folder; she will then be able to use Monticello to browse and load it. 
Адресат должен будет поместить этот файл в своей папке \emph{package-cache}, после чего получит возможность просмотреть и загрузить его с помощью Monticello.
%(It is also possible to load it using the file list, but there is a difference between loading a \ct{.mcz} file using a file list and using Monticello \sd{check}.)

%\dothis{Open the Monticello browser from the \menu{World} menu.}
\dothis{Откройте браузер Monticello из главного (\menu{World}) меню.}
%In the right-hand pane of the browser (see \figref{monticello1}) is a list of Monticello repositories, which will include all of the repositories from which code has been loaded into the image that you are using.  
На правой панели браузера (см. \figref{monticello1}) находится список репозиториев Monticello, в который входят все репозитории из которых в ваш текущий образ загружался код.
%In addition to \sqsrc servers, Monticello repositories can live in a variety of other places, the simplest being a directory on your local disk.

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{MonticelloBrowser}}}
	{\centerline {\includegraphics[scale=0.7]{MonticelloBrowser}}}
%\caption{The Monticello browser.
\caption{Браузер Monticello.
\figlabel{monticello1}}
\end{figure}

%At the top of the list in the Monticello browser is a repository in a local directory called the \emphind{package cache}, which caches copies of the packages that you have loaded or published over the network. This local cache is really handy because it lets you keep your own local history; it also allows you to work in places where you do not have internet access, or where access is slow enough that you do not want to save to a remote repository very frequently.
В верхней части списка находится репозиторий \emphind{package cache}, расположенный в локальном каталоге. В этом репозитории кешируются копии пакетов, которые вы загрузили или опубликовали в сети. Локальный кеш удобен, т.к. позволяет вам хранить историю локально. Он также позволяет вам полноценно работать в местах, где нет доступа к интернету, или где интернет-соединение слишком медленное и вы не хотите часто сохранять пакет в удалённый репозиторий.


%\subsection{Saving and loading code with Monticello.}
\subsection{Сохранение и загрузка кода с помощью Monticello.}
%On the left-hand side of the Monticello browser is a list of packages that have a version loaded into the image; packages that have been modified since they were loaded are marked with an asterisk.  (These are sometimes referred to as \subind{package}{dirty} packages.)  If you select a package, the list of repositories is restricted to just those repositories that contain a copy of the selected package.
В левой части браузера Monticello находится список пакетов, загруженных в образ. Пакеты, в которые после загрузки были внесены изменения помечены звёздочкой (их иногда называют <<грязными>> (\subind{package}{dirty}). Если вы выберете пакет, список репозиториев справа сократится до тех, которые содержат копию выбранного пакета.
\seeindex{*}{package, dirty}
\seeindex{dirty package}{package, dirty}

%What is a package?  For now, you can think of a package as a group of  class and method categories that share the same prefix.  Since we put all of the code for the Lights Out game into the category called \scat{PBE-LightsOut}, we can refer to it as the \ct{PBE-LightsOut} package.

%\dothis{Add the \ct{PBE-LightsOut} package to your Monticello browser using the \button{+Package} button and type \ct{PBE-LightsOut}.}
\dothis{Добавьте пакет \ct{PBE-LightsOut} в ваш браузер Monticello, используя кнопку \button{+Package} и введя \ct{PBE-LightsOut}.}

%\subsection{\ind{\sqsrc}: a \ind{SourceForge} for \pharo.} 
\subsection{\ind{\sqsrc} --- \ind{SourceForge} для \pharo.} 
%We think that the best way to save your code and share it is to create an account for your project on a \sqsrc server. 
Мы считаем, что лучший способ хранить код и организовывать к нему совместный доступ, --- это создать аккаунт для вашего проекта на сервере \sqsrc.
%\sqsrc is like SourceForge\footnote{\url{http://sourceforge.net}}: it is a web front-end to a HTTP Monticello server that lets you manage your projects.
\sqsrc --- это что-то вроде SourceForge\footnote{\url{http://sourceforge.net}}, --- интерфейс к HTTP серверу Monticello, позволяющий вам управлять своими проектами.
%There is a public \sqsrc server at \url{http://www.squeaksource.com}, and a copy of the code related to this book is stored there at \url{http://www.squeaksource.com/PharoByExample.html}. You can look at this project with a web browser, but it's a lot more productive to do so from inside \pharo, using the Monticello browser, which lets you manage your packages.
Существует публичный \sqsrc-сервер, расположенный по адресу \url{http://www.squeaksource.com}. Кстати, там хранится копия кода, входящего в эту книгу: \url{http://www.squeaksource.com/PharoByExample.html}. Вы можете изучать этот проект через веб-браузер, но гораздо продуктивнее делать это из \pharo с помощью браузера Monticello.

%\dothis{Open a web browser to \url{http://www.squeaksource.com}.
\dothis{Откройте в веб-браузере страницу \url{http://www.squeaksource.com}.
%Create an account for yourself and then create (\ie ``register'') a project for the Lights Out game.}
Создайте собственный аккаунт, и зарегистрируйте проект для нашей игры Lights Out.}
%\sqsrc will show you the information that you should use when adding a repository using the Monticello browser. 
\sqsrc предоставит вам информацию, которую вы должны использовать для добавления репозитория в браузер Monticello.

%Once your project has been created on \sqsrc, you have to tell your \pharo system to use it. 
После того, как проект на \sqsrc был создан, вы должны сказать \pharo, как его использовать.

%\dothis{With the \ct{PBE-LightsOut} package selected, click the \button{+Repository} button in the Monticello browser.}  You will see a list of the different types of Repository that are available; to add a \sqsrc repository select \menu{HTTP}. You will be presented with a dialog in which you can provide the necessary information about the server.
\dothis{Выберите пакет \ct{PBE-LightsOut}, а затем кликните по кнопке \button{+Repository} в браузере Monticelo.} Вы увидите список различных типов доступных репозиториев. Чтобы добавить репозиторий \sqsrc выберите пункт \menu{HTTP}; откроется диалог, в котором вам нужно предоставить необходимую информацию о сервере.
You should copy the presented template to identify your \sqsrc project, paste it into Monticello and supply your initials and password:
Скопируйте шаблон подключения проекта с его странички на \sqsrc, вставьте этот шаблон в Monticello и введите свои инициалы и пароль:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{ваш проект}!'
    user: '!\emph{ваши инициалы}!' 
    password: '!\emph{ваш пароль}!'
\end{code}   

\noindent
%If you provide empty initials and password strings, you can still load the project, but you will not be able to update it:
Если вы оставите строки инициалов и пароля пустыми, вы всё же сможете загрузить проект, но не сможете обновлять его:

\needlines{5}
\begin{code}{}
MCHttpRepository 
    location: 'http://www.squeaksource.com/!\emph{YourProject}!'
    user: '' 
    password: ''
\end{code}   

%You can then load the code in your image by selecting the version you want. You can browse the code without loading it, using the \button{Browse} button.
%Once you have accepted this template, your new repository should be listed on the right-hand side of the Monticello browser.
После того, как вы приняли этот шаблон, ваш новый репозиторий должен быть представлен на правой панели браузера Monticello.

\begin{figure}[hbt]
\ifluluelse
	{\centerline {\includegraphics[width=\textwidth]{BrowseRepository}}}
	{\centerline {\includegraphics[scale=0.7]{BrowseRepository}}}
%\caption{Browsing a Monticello Repository
\caption{Просмотр репозитория Monticello
\figlabel{monticello3}}
\end{figure}

%\dothis{Click on the \button{Save} button to save a first version of your Lights Out game on \sqsrc.}
\dothis{Нажмите на кнопку \button{Save} чтобы сохранить первую версию вашей игры Lights Out на \sqsrc.}

%To load a package into your image, you must first select a particular version.  You can do this in the repository browser, which you can open using the \button{Open} button or the \actclick menu.  Once you have selected a version, you can load it onto your image.
Чтобы загрузить пакет в свой образ, выберите его определённую версию. Вы можете сделать это в браузере репозитория, открыть который можно нажав на кнопку \button{Open} или посредством меню по \actclick. После того, как вы выбрали верию пакета, вы можете загрузить его в образ.

%\dothis{Open the \ct{PBE-LightsOut} repository you have just saved.}
\dothis{Откройте репозиторий \ct{PBE-LightsOut}, который только что создали.}

%Monticello has many more capabilities, which will be discussed in depth in \charef{env}.
У Monticello имеется гораздо больше возможностей, которые будут подробно рассмотрены в \charef{env}.
%You can also look at the on-line documentation for Monticello at \url{http://www.wiresong.ca/Monticello/}.
Вы также можете обратиться к on-line документации Monticello по адресу \url{http://www.wiresong.ca/Monticello/}.

%=================================================================
\section{Chapter summary}
In this chapter you have seen how to create categories, classes and methods.  You have see how to use the browser, the inspector, the debugger and the Monticello browser.

\begin{itemize}
  \item Categories are groups of related classes.
  \item A new class is created by sending a message to its superclass.
  \item Protocols are groups of related methods.
  \item A new method is created or modified by editing its definition in the browser and then \emph{accepting} the changes.
  \item The inspector offers a simple, general-purpose GUI for inspecting and interacting with arbitrary objects.
  \item The browser detects usage of undeclared methods and variables, and offers possible corrections.
  \item The \ct{initialize} method is automatically executed after an object is created in \pharo. You can put any initialization code there.
  \item The debugger provides a high-level GUI to inspect and modify the state of a running program.
  \item You can share source code \emph{filing out} a category.
  \item A better way to share code is to use Monticello to manage an external repository, for example defined as a \sqsrc project.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================
%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
