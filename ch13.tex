\documentclass[a4paper,10pt,twoside]{book}
%=============================================================
\input{common.tex}
\graphicspath{{figures/}} % for \dothis
%=============================================================
\begin{document}
\sloppy
\mainmatter

%=============================================================
\setcounter{chapter}{12} % и тогда следующая глава будет 13
\chapter{Классы и метаклассы}
%=============================================================

Как мы видели в Главе 5, в Smalltalk всё~--- это  объект, и каждый объект~--- это экземпляр класса. И классы не исключение: классы~--- это объекты, а объекты класса~--- это экземпляры других классов. Эта модель объекта захватила сущность объектно-ориентированного программирования: она проста, изящна и однородна. Однако, последствия этого единообразия могут сбивать с толку новичков. Цель этой главы состоит в том, чтобы показать, что здесь нет ничего сложного, <<волшебного>> или особенного: только простые правила, которые одинаково применяются. Следуя этим правилам вы можете всегда понять почему ситуация такая, какая есть.


\section{Правила для классов и метаклассов}

Модель объекта основана на ограниченном числе понятий, примененных единоообразно. Проектировщики Smalltalk применили бритву Оккама, т.е.  отказались от любого фактора, приводящего к модели более сложной, чем это необходимо.

Чтобы освежить вашу память, вот правила модели объекта, которые мы исследовали в Главе 5.




\begin{enumerate}[label={\textbf{Rule \arabic{*}}.}, ref={Rule \arabic{*}}, leftmargin=*]
\item[Правило 1.]{}
 Все~--- это объект..
\item[Правило 2.]{}
 Каждый объект~--- это экземпляр класса.
\item[Правило 3.]{}
 У каждого класса есть суперкласс.
\item[Правило 4.]{}
 Все операции происходят, посылая сообщения.
\item[Правило 5.]{}
 Метод поиска следует за цепью наследования.
\end{enumerate}


Как мы упоминали во введении в эту главу, следствие Правила 1 говорит о том, что классы~--- это также  объекты, таким образом, Правило 2 говорит нам, что классы также  должны быть экземплярами классов. Класс класса называют метаклассом. Метакласс  для вас создается автоматически, когда вы создаете класс. Большую часть времени вы не должны заботиться или думать о метаклассах. Однако, каждый раз то, когда вы используете браузер, чтобы просмотреть <<сторону класса>> класса, нужно помнить, что вы фактически просматриваете разные классы. Класс и его метакласс - два отдельных класса  даже при том, что первый~---  это экземпляр последнего.

Чтобы должным образом объяснить классы и метаклассы, мы должны расширить правила из Главы 5 со следующими дополнительными правилами:

\begin{enumerate}[label={\textbf{Rule \arabic{*}}.}, ref={Rule \arabic{*}}, leftmargin=*]
\item[Правило 6.]{}
 Каждый класс~--- экземпляр метакласса.
\item[Правило 7.]{}
 Иерархия метаклассов параллельна иерархии классов.
\item[Правило 8.]{}
 Каждый метакласс наследуется из классов Class and Behavior.
\item[Правило 9.]{}
Каждый метакласс~---  экземпляр  Metaclass.
\item[Правило 10.]{}
 Метакласс Metaclass~--- экземпляр  Metaclass.
\end{enumerate}



Вместе эти 10 правил заканчивают объектную модель Smalltalk.
Мы еще раз кратко повторно просмотрим 5 правил из Главы 5 с небольшим примером. Затем  мы обратим внимание на новые правила, используя тот же самый пример.

\section{Пересмотр модели объекта Smalltalk}

Так как все~--- это объект,  синий цвет в Smalltalk~--- это также объект.
\begin{code}{}
Color blue --> Color blue
\end{code}


Каждый объект - это экземпляр класса. Класс синего цвета~---  это класс Color:
\begin{code}{}
Color blue class --> Color
\end{code}

Интересно, если мы установим значение цвета alpha, то мы получим экземпляр другого класса, а именно TranslucentColor:
\begin{code}{}
(Color blue alpha: 0.4) class --> TranslucentColor
\end{code}

Мы можем создать морф и задать его цвет, который есть этот полупрозрачный цвет:
\begin{code}{}
EllipseMorph new color: (Color blue alpha: 0.4); openInWorld
\end{code}

Вы можете увидеть эффект в рисунке 13.1. (рисунок)

По Правилу 3 у каждого класса есть суперкласс. Color~--- это суперкласс класса TranslucentColor , а Object~--- это суперкласс класса Color:
\begin{code}{}
TranslucentColor superclass --> Color
Color superclass --> Object
\end{code}

Все операции происходят, посылая сообщения (Правило 4), таким образом, мы можем заключить, что blue~--- это сообщение в суперкласс Color, class и alpha~--- это  сообщения к синему цвету, openInWorld~--- это сообщение к морфу эллипса, и superclass~--- сообщение к TranslucentColor и Color. Получатель в каждом случае~--- это объект, так как каждая вещь в Smalltalk~--- объект, но некоторые из этих объектов~--- также классы. Метод поиска следует за цепью наследования (Правило 5), (поэтому когда мы посылаем сообщение class к результату Color blue alpha:~0.4) так как, когда мы посылаем сообщения класса  в результат Color blue alpha:~0.4, сообщение будет обработано, когда соответствующий метод будет найден в классе Object, как показано в рисунке 13.2.

Рисунок 13.2: Отправка сообщения полупрозрачному цвету.

Рисунок  отражает суть is-a отношения. Наш полупрозрачный синий объект translucentBlue~--- это экземпляр TranslucentColor, но мы также можем сказать, что это экземпляр Color и экземпляр Object, так как он отвечает на сообщения, определенные во всех этих классах. В самом деле, есть сообщение isKindOf:, которое вы можете отправить  любому объекту, чтобы узнать, находится ли он в отношении с данным  классом.

\begin{code}{}
translucentBlue := Color blue alpha: 0.4.
translucentBlue isKindOf: TranslucentColor --> true
translucentBlue isKindOf: Color --> true
translucentBlue isKindOf: Object --> true
\end{code}

\section{Каждый класс~--- экземпляр метакласса}

Как мы уже говорили в разделе 13.1, классы, экземпляры которого являются сами классы, называют метаклассами.

Метаклассы являются неявными. Метаклассы создаются автоматически, когда вы определяете класс. Мы говорим, что они неявны, поскольку вы, как программист, никогда не будете беспокоиться о них. Неявные метаклассы создаются для каждого класса, который вы создаете, так что каждый метакласс имеет только один экземпляр.

В то время как обычные классы именуются  глобальными переменными, метаклассы являются анонимными. Тем не менее, мы всегда можем обратиться к ним через класс, который является их экземпляром. Например, Color class - это класс класса Color, и Object class~--- это класс класса Object:

\begin{code}{}
Color class --> Color class
Object class --> Object class
\end{code}

Рисунок 13.3 показывает, как каждый класс является экземпляром своего анонимного метакласса.

Рисунок 13.3: Метаклассы класса Transluсent и их суперклассы.

Так как классы~--- это тоже объекты, нам  становится легче запрашивать их путем посылки сообщений. Давайте посмотрим:

\begin{code}{}
Color subclasses --> {TranslucentColor}
TranslucentColor subclasses --> #()
TranslucentColor allSuperclasses --> an OrderedCollection(Color Object
ProtoObject)
TranslucentColor instVarNames --> #('alpha')
TranslucentColor allInstVarNames --> #('rgb' 'cachedDepth' 'cachedBitPattern' '
alpha')
TranslucentColor selectors --> an IdentitySet(#pixelValueForDepth:
#pixelWord32 #convertToCurrentVersion:refStream: #isTransparent
#scaledPixelValue32 #bitPatternForDepth: #storeArrayValuesOn: #setRgb:alpha:
#alpha #isOpaque #pixelWordForDepth: #isTranslucentColor #hash #isTranslucent
#alpha: #storeOn: #asNontranslucentColor #privateAlpha
#balancedPatternForDepth:)
\end{code}

\section{Иерархия метаклассов параллельная иерархии классов}

Правило 7 говорит, что суперкласс метакласса не может быть произвольным классом: он вынужден быть метаклассом суперкласса уникального экземпляра этого  метакласса.

\begin{code}{}
TranslucentColor class superclass --> Color class
TranslucentColor superclass class --> Color class
\end{code}

Вот то, что мы подразумеваем под иерархией метаклассов параллельной иерархии классов.
Рисунок 13.4 показывает, как это работает в иерархии TranslucentColor.


Рисунок 13.4: Иерархия метакласса параллельная иерархии класса.

\begin{code}{}
TranslucentColor class --> TranslucentColor class
TranslucentColor class superclass --> Color class
TranslucentColor class superclass superclass --> Object class
\end{code}

Однородность между классами и объектами. Интересно сделать шаг назад на мгновение и осознать, что нет никакой разницы между отправкой сообщения объекту и отправкой сообщения  классу. В обоих случаях поиск соответствующего метода начинается в классе приемника, и продолжается по цепи наследования.

Таким образом, сообщения, отправленные на классы должны следовать в метаклассы по цепи наследства. Рассмотрим, например, метод blue, который реализуется на стороне класса Color. Если мы посылаем сообщение blue классу TranslucentColor, то оно будет искать тот же путь, что и любое другое сообщение. Поиск начинается в TranslucentColorclass и продолжается по иерархии метакласса, пока не найдет Color class (см. рисунок 13.5).


\begin{code}{}
TranslucentColor blue --> Color blue
\end{code}

Обратите внимание, что в результате мы получаем  обычный Color blue, и не одного полупрозрачного. И ни какой магии!

Рисунок 13.5: Сообщение поиска для классов такое же, как и для обычных объектов.

Итак, мы видим, что есть один единый вид метода поиска в Smalltalk. Классы - это просто объекты, и мы будем рассматривать их, как и любые другие объекты. Классы имеют возможность создавать новые экземпляры только потому, что классы отвечают на сообщение new, и потому, что метод  для new знает, как создать новый экземпляр. Как правило, объекты не классов не понимают это сообщение, но если у вас есть уважительная причина, чтобы отправить его, то ничто не может остановить вас добавить новый метод не метаклассу.

Так как классы - это  объекты, мы можем также проверить их.

Проверим Color Blue и Color

Обратите внимание, что в одном случае вы проверяете экземпляр класса Color, а в другом случае сам класс Color. Вы можете немного запутаться, потому что заголовок проверки называется класс проверяемого объекта.

Проверка для Color позволяет вам видеть суперкласс, переменные экземпляра, словарь методов, а также класс Color, как показано на рисунке13.6.

Рисунок 13.6: Классы~--- также объекты.

\section{Каждый метакласс наследуется из классов Class and Behavior.}

Каждый метакласс~--- это класс, следовательно, он наследуется из класса. Класс, в свою очередь наследуется из своих суперклассов ClassDescription и Behavior. Так как каждая вещь в Smalltalk~--- это объект, все эти классы в конечном счете наследуются из класса Object. Полную картину мы можем увидеть на рисунке 13.7.

Рисунок 13.7: Метаклассы наследуется из классов Class and Behavior.

Где метод new определен? Чтобы понять важность того, что метаклассы наследуются из классов Class и Behavior, полезно знать, где определяется метод new и как он будет найден. Когда сообщение new отправляется классу, оно ищется по цепи его метакласса и, в конечном счете, в его суперклассах Class, ClassDescription и Behavior, как показано на рисунке 13.8.

Вопрос "Где метод new определяется?" имеет решающее значение. New сначала определен в классе Behavior, но он может быть переопределен в его подклассах, в том числе мы можем определить его в любом из метаклассов класса, когда это необходимо. Теперь, когда сообщение new отправлено классу, оно ищется, как обычно, в метаклассе этого класса, затем по цепи суперкласса вплоть до класса Behavior, если оно не было переопределено по пути.

Обратите внимание, что результат отправки сообщения new классу TranslucentColor~--- это  экземпляр класса TranslucentColor, а не класса Behavior, хотя этот метод ищется и в классе Behavior! Метод new всегда возвращает экземпляр себе и классу, который получает сообщение, даже если он реализован в другом классе.

\begin{code}{}
TranslucentColor new class --> TranslucentColor "not Behavior"
\end{code}

Распространенной ошибкой является поиск new в суперклассах полученных классов. То же самое касается new:, стандартных сообщений для создания объекта заданного размера. Например, Array new: 4 создает массив из 4 элементов. Этот метод не будет определен в Array или в любом из его суперклассов. Вместо этого вы должен искать его в классе Array и его суперклассов, так как именно там начнется поиск.

Рисунок 13.8: Поиск обычного сообщения new по цепи метакласса.

Обязанности классов Behavior, ClassDescription и Class. Behavior обеспечивает минимальное состояние, необходимое для объектов, которые имеют экземпляры: оно включает в себя ссылку
суперкласса, словарь методов и описание экземпляров (например, представление и номер). Класс Behavior наследуется из класса Object, так что он, и все его подклассы, могут вести себя как объекты

Behavior является также базовым интерфейсом для компилятора. Он предоставляет методы для создание словаря методов, компиляции методов, создания экземпляров (например, new, basicNew, new: и basicNew:), управления иерархией классов (например, superclass:, addSubclass:), доступа к методам (например, selectors, allSelectors, compiledMethodAt:), обращения к экземплярам и переменным (например, allInstances, instVarNames\dots), доступа к иерархии классов (например,  superclass, subclasses) и запросов (например, hasMethods, includesSelector, canUnderstand:, inheritsFrom:, isVariable).

ClassDescription это абстрактный класс, который предоставляет средства, необходимые его двум прямых подклассам, Class и Metaclass. ClassDescription добавляет ряд средств для базы, предусмотренной Behavior: например, именованные переменные экземпляра, классификация методов в протоколах, понятие имени (абстрактное), поддержка наборов изменений и регистрация изменений, и много других механизмов, необходимых для выполнения изменений.

Class представляет общее поведение всех классов. Он предоставляет имя класса, методы компиляции, способ хранения и переменные экземпляра. Он обеспечивает конкретное представление для класса имен переменных и общего объединения переменных (addClassVarName:, addSharedPool:, initialize). Class знает, как создавать экземпляры, поэтому все метаклассы должны наследоваться в конечном счете из Class .

Рисунок 13.9: Каждый метакласс~--- это Metaclass.



\section{Каждый метакласс~--- это экземпляр Metaclass}

Метаклассы~--- это тоже объекты, они являются экземплярами класса Metaclass, как показано
на рисунке 13.9. Экземпляры класса Metaclass являются анонимными метаклассами, каждый из которых имеет только один экземпляр, который является классом.

Metaclass представляет общее поведение метакласса. Он предоставляет методы для
создания экземпляра (subclassOf:) создания инициализируемых экземпляров метаклассов в
единственный экземпляр, инициализации переменных класса, экземпляров метакласса, метода
компиляции, и информацию о классе (ссылки наследования, переменные экземпляра, и т.д.).

\section{Метакласс Metaclass~--- это экземпляр Metaclass.}

Последний вопрос, на который нужно ответить: что такое класс класса Metaclass?
Ответ прост: это метакласс, поэтому он должен быть экземпляром класса Metaclass, как и все другие метаклассы в системе (см. рисунок 13.10).


Рисунок 13.10: Все метаклассы, в том числе метакласс класса Metaclass, являются экземплярами Metaclass.

Рисунок показывает, что все метаклассы, в том числе метакласс класса Metaclass, являются экземплярами Metaclass. Если сравнить рисунки 13.9 и 13.10, вы увидите, как иерархия метаклассов  прекрасно отражает иерархию классов и все пути к объектам классов.

Следующие примеры показывают нам, как мы можем запросить иерархию классов, чтобы
продемонстрировать, что рисунок 13.10 корректен.(На самом деле вы увидите, что мы невинно солгали, ведь Object class superclass ?? ProtoObject class не относится к классу Class. В Pharo, мы должны перейти еще на один суперкласс выше, чтобы достичь Class).


\begin{example}[history]{Иерархия классов.}{}
TranslucentColor superclass --> Color
Color superclass --> Object
\end{example}


\begin{example}[history]{Параллельная иерархия метаклассов.}{}
TranslucentColor class superclass --> Color class
Color class superclass --> Object class
Object class superclass superclass --> Class "NB: skip ProtoObject class"
Class superclass --> ClassDescription
ClassDescription superclass --> Behavior
Behavior superclass --> Object
\end{example}

\begin{example}[history]{Экземпляры метаклассов.}{}
TranslucentColor class class --> Metaclass
Color class class --> Metaclass
Object class class --> Metaclass
Behavior class class --> Metaclass
\end{example}

\begin{example}[history]{Метаклассы Классов~--- это Metaclass.}{}
Metaclass class class --> Metaclass
Metaclass superclass --> ClassDescription
\end{example}

\section{Заключение}

Теперь вы должны лучше понять организацию классов и влияние однородности объектной модели. Если вы заблудились или запутались, вы всегда должны помнить, что ключом к разгадке является посылка сообщений: вы всегда найдете метод в классе приемника. Это ключ работает для любого приемника. Если метод не найдется в классе приемника, он найдется в его суперклассах.

\begin{itemize}
\item
 Каждый класс~--- это экземпляр метакласса. Метаклассы являются неявными. Метакласс создается автоматически при создании класса, который будет являться его единственным экземпляром.
\item
 Иерархия метаклассов параллельна иерархии классов. Метод поиска классов параллелен  методу поиска простых объектов, и следует по цепи суперкласса метакласса.
\item
 Каждый метакласс наследуется из классов Class и Behavior. Каждый класс~--- это Class. Метаклассы и классы также должны наследоваться из Class. Behavior обеспечивает общее поведение всех объектов, у которых есть экземпляры.
\item
 Каждый метакласс~--- это экземпляр Metaclass. ClassDescription обеспечивает всеми общими средствами, которые необходимы для Class и Metaclass.
\item
 Метакласс класса Metaclass~--- это экземпляр Metaclass. Отношение instance-of образует замкнутый цикл, поэтому Metaclass class class ?? Metaclass.
\end{itemize}

\end{document}
