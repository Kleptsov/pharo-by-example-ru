







\documentclass[a4paper,10pt,twoside]{book}
%=============================================================
\input{common.tex}
\graphicspath{{figures/}} % for \dothis
%=============================================================
\begin{document}
\sloppy


\mainmatter


%=============================================================
\setcounter{chapter}{0} % и тогда следующая глава будет 1
\chapter{Краткий обзор Pharo}
%=============================================================


В этой главе мы постараемся провести содержательный обзор по Pharo с целью помочь Вам познакомиться с удобной средой. Будет много возможностей попробовать разные вещи, поэтому было бы неплохо, если в процессе чтения у Вас был бы компьютер.


Мы будем использовать этот символ: \dothis{} в качестве отметок в тексте, где Вы должны попробовать что-то в Pharo. В частности,  Вы запустите Pharo, узнаете различные способы взаимодействовать с системой и обнаружите  некоторые из основных инструментов. Вы также изучите, как определить новый метод, создать объект и послать ему сообщения.

\section{ Приступая  к работе}


Pharo доступен в качестве бесплатной загрузки с http://pharo-project.org. Там
три части, которые вам необходимо скачать, состоящие из четырех файлов (см.Рис. 1.1).

Рис. 1.1: Загружаемые Pharo-файлы для одной из поддерживаемых платформ

\begin{itemize}
\item[1.]
Виртуальная машина (VM) является единственной частью системы, которая отличается для каждой операционной системы  и процессора. Предварительно скомпилированные виртуальные машины доступны для всех основных вычислительных сред. На Рис.1 мы видим, что VM для выбранной платформы  называется Pharo.exe.
\item[2.]
Исходный  .sources  файл  содержит исходный код для всех частей Pharo и изменяется очень часто. На Рис.1.1 он носит название  SqueakV39.sources1.\footnote{Pharo унаследован от  Squeak3.9, и теперь делит  VM с Squeak.}
\item[3.]
Изображение текущей системы~--- это снимок управляемой Pharo системы,  застывший во времени. Он состоит из двух файлов:  .image файл (файл образа, образ), который содержит состояние всех объектов в системе (в том числе классов и методов, т.к. они тоже являются объектам ),  и .changes файл (файл изменений),  который содержит журнал всех изменений в исходном коде системы. На Рис.1.1 эти файлы названы pharo.image и pharo.changes соответственно.
\end{itemize}


\dothis{Загрузите и установите Pharo на Ваш компьютер.}


Мы рекомендуем Вам использовать изображения, представленные на странице  Pharo by Example.\footnote{http://PharoByExample.org}

Б\'ольшая часть вводного материала этой книги может работать с любой версией Pharo,  так, если у Вас уже была установленная среда, то можете успешно продолжить ее изучение. Однако, не стоит удивляться, если Вы заметите различия в интерфейсе или исполнении своей среды и той, что здесь описана.


При работе с Pharo  .image  и  .сhange  файлы будут изменены, поэтому Вам необходимо  всякий раз убеждаться в их читаемости (поэтому вам нужно убедиться, что они доступны для записи). Всегда держите оба файла вместе. Никогда не изменяйте  их непосредственно с помощью текстового редактора, поскольку Pharo использует их для хранения объектов, с которыми Вы работаете,  и регистрирует изменения, совершенные Вами в исходном коде.  Неплохо было бы делать резервные копии загруженных .image и .change файлов с той целью, что впоследствии Вы сможете создать новый образ и перезагрузить свой код.


Исходный .sources файл и VM могут быть использованы только для чтения и разделяются между несколькими пользователями. Все эти файлы могут лежать в одной и той же директории, но так же возможно разместить виртуальную машину и .sources файлы в различные директории, где у каждого есть доступ к ним. Делайте все для улучшения Вашего стиля работы и операционной системы.


\subsection{Запуск}
Для старта Pharo сделайте следующее: перетащите .image файл на иконку виртуальной машины или дважды кликнете по этому файлу или еще один вариант:  пропишите в командной строке имя виртуальной машины и путь к .image файлу. (В случае если на вашем компьютере установлено несколько виртуальных машин, операционная система возможно не сможет определить нужную из них. В этом случае наиболее безопасным будет перетащить образ на VM или воспользоваться командной строкой.)

Как только Pharo начнет работу, Вы увидите одно большое окно, возможно содержащее некоторые открытые окна рабочей области (workspace). Но как же двигаться дальше?~--- это неясно.  Вы могли бы заметить строку-меню, но в большинстве своем Pharo использует контекстно-зависимые всплывающие меню.



Рис.1.2 Новый образ  http://PharoByExample.org image.


\dothis{Старт Pharo. Вы можете отклонить открытые рабочие окна, кликнув по красной кнопке в левом верхнем углу рабочей области окна.}


Вы можете свернуть окна, нажав на оранжевую кнопку, или развернуть их на весь экран, кликнув по зеленой кнопке.

First Interaction. A good place to get started is the world menu shown in
Рис. 1.3 (a).

\subsection{Первые действия}

Рассмотрим меню, изображенные на Рис.1.3(а).


\dothis{Кликнете мышью на фоне главного окна для просмотра world-меню, затем выберите \menu{Workspace} для создания новой рабочей области.}

Smalltalk был первоначально разработан для компьютера с мышью, имеющей три кнопки. Если у Вашей мыши меньше трёх кнопок, то Вам придется нажимать дополнительные комбинации клавишей мыши, чтобы имитировать нужные комбинации. Двухкнопочная мышь хорошо справляется с задачами Pharo (владельцам однокнопочной мыши советуем приобрести мышь с двумя кнопками и с кликабельным колесиком прокрутки, так вы облегчите себе работу с Pharo).


Pharo избегает таких словосочетаний как <<щелкните левой кнопкой мыши>>, потому что разные компьютеры, мыши, клавиатуры и персональные конфигурации означают, что разным пользователям нужно нажимать различные кнопки для достижения одного и того же эффекта.


Рис.1.3: World-меню, контекстное меню и область морфа.


Первоначально Smalltalk вводил цвета для обозначения различных кнопок мыши.\footnote{Цвета кнопок были красными, желтыми и синими. Авторы этой книги уже и  не вспомнят, какая кнопка какой цвет обозначает.} С тех пор на помощь многим пользователям приходят различные кнопки (Ctrl, Alt и т.д.), мы же,  в свою очередь, будем использовать следующие термины:

\begin{enumerate}
\item[клик:] чаще всего используемая кнопка мыши и, как правило, эквивалентна клику на однокнопочной мыши без использования клавиш модификаторов; Кликнете по образу, чтобы открыть меню World (Рис.1.3(а)).

\item[Действие-клик:] это следующая по популярности кнопка; она используется для создания контекстного меню, т.е. меню, которое предлагает различные наборы действий в зависимости оттого, на что указывает мышь. См. Рис.1.3 (b). Если Вы работает не с многокнопочной (с тремя кнопками) мышью, то Вам следует настроить модификатор-клавишу Ctrl, как если бы это был щелчок-действие кнопкой мыши.

\item[Meta-click:] Наконец, Вы можете meta-щелкнуть по любому объекту, отображаемому в образе для активации <<области морфа(morphic)>>, множество ручек, которые используются для выполнения операций вращения или изменения самих объектов, расположенных на экране. См. Рис. 1.3 (с)\footnote{Обратите внимание, что morphic- ручки по умолчанию неактивны, но чтобы это исправить необходимо изменить Настройки Браузера, что мы впоследствии  и увидим.}. Если Вы позволите мыши задержаться на ручке, то воздушный шар покажет необходимую справку по функции. В Pharo Ваш meta-click зависит от Вашей операционной системы: либо Вы должны нажать shift ctrl, либо shift.

\end{enumerate}



\dothis{Напечатайте текущее время в рабочей области. Выберете \menu{print it} в контекстном меню рабочей области.}

Правшам можно рекомендовать настраивать свои мыши так: щелчок осуществлять левой кнопкой мыши, щелчок-действие~--- правой, а meta-click~--- колесиком прокрутки. Если вы используете Macintosh без второй кнопки мыши, то можете удерживать нажатой клавишу и кликать мышкой.  Однако мы еще раз советуем Вам приобрести мышь, по крайней мере, с двумя кнопками.




Вы можете самостоятельно настроить конфигурацию своей мыши, но и у Pharo есть свои настройки мыши и meta-клавиш на клавиатуре. В настройках браузера (\menu{System\dots \go Preferences\dots \go Preference Browser\dots}).  \menu{Keyboard} категория содержит опцию \menu{swapControlAndAltKeys}, которая переключается на действие-клик и функции meta-click. Также есть опции, дублирующие варианты командных клавиш.


\section{Меню World}


\dothis{Кликните ещё раз на фон Pharo.}

 Вы снова увидите  World меню. Большинство Pharo-меню не являются модальными; вы можете оставить меню на экране ровно столько, сколько вам понадобится, для этого нажмите на push pin иконку в верхнем правом углу. Проделайте это.

 World-меню предоставляет вам простые способы (средства) для доступа ко многим инструментам, которые может предложить Pharo.

 \dothis{Подробнее ознакомьтесь с World и Tools\dots меню (figure 1.3(a))}


Рис.1.4 Выбор программы просмотра


Вы увидите список некоторых основных инструментов Pharo, включая браузер и рабочее пространство. Мы столкнёмся с большей частью инструментария в последующих главах.




\section{Отправка сообщений}

\dothis{Откройте рабочее пространство.  Введите следующий текст: }

\begin{code}{}
BouncingAtomsMorph new openInWorld
\end{code}


\dothis{Теперь клик-действие. Должно появиться меню. Выберите do it (d) (Посмотрите Figure 1.5)}

Окно, содержащее большое количество bouncing atoms, должно открываться в левом верхнем углу образа (image) Pharo.

Вы только что вычислили свое первое Smalltalk-выражение! Вы отправили сообщение new к  классу BouncingAtomsMorph, обработанное в новом экземпляре BouncingAtomsMorph, затем следует  сообщение openInWorld к этому экземпляру. Сам класс BouncingAtomsMorph решает, что делать с сообщением new, то есть, класс ищет его methods для обработки сообщения new и реагирует нужным образом. Похожим образом экземпляр BouncingAtomsMorph ищет его метод для ответа на openInWorld и принимает соответствующие действия.

Если Вы немного пообщаетесь со смолтокерами, вы быстро заметите, что они, в общем,  не используют такие выражения как: "вызов операции" или "вызвать метод", но вместо этого они будут говорить "послать сообщение". Это отражает идею, что объекты несут ответственность за свои действия. Вы никогда не скажите объекту что делать, вместо этого вы вежливо попросите сам объект что-либо сделать, посылая ему сообщение.  И объект, а никак не Вы, выбирает подходящий метод для ответа на Ваше сообщение.


\section{Сохранение, выход и перезагрузка Pharo-сессии}


\dothis{Теперь кликните на bouncing atoms окна и перетащите в любое место, которое Вам по нраву. И сейчас у Вас есть демонстрация "in hand".  Поместите ее, просто где-нибудь кликнув.}


\dothis{Выберите \menu{World \go Save as},  введите название myPharo, и нажмите на кнопку \button{OK}. Затем выберите \menu{World \go Save and quit.}}

Если Вы перейдете в то место, где у вас хранится образ и там измените файлы, вы обнаружите два новых файла с названиями "myPharo.image" и "myPharo.changes", которое отражает работающее состояние образа Pharo в момент перед тем, как Вы выполнили команду в Pharo Save and quit. Если Вам захочется, то  можете переместить эти два файла в любое место на Вашем диске, однако, если сделаете это, то может понадобиться  (в зависимости от Вашей операционной системы)  также перемещать, копировать или линковаться к виртуальной машине и исходным файлам (sources).

\dothis{ Запустите Pharo из только что созданного файла "myPharo.image".}

Теперь точно представьте себе то, что было перед выходом из Pharo. BouncingAtomsMorph снова перед Вами и атомы продолжают двигаться с того же места как и было до того как  нажали кнопку выхода.

Когда вы запускаете Pharo в первый раз, виртуальная машина Pharo загружает image файл, который вы предоставляете. Этот файл содержит снимки большого количества объектов, включая огромное количество уже существующего кода и большое количество программных инструментов (каждый из которых является объектом).  Поскольку Вы работаете с Pharo, то будете посылать сообщения этим объектом, создавать новые объекты, а некоторые из этих объектов умрут и память, которая была использована для них, будет освобождена (т.е. так называемое собирание мусора~--- garbage-collected).

Когда Вы выходите из Pharo, вы в обычном порядке сохраняете снимок, который содержит все Ваши объекты. Если нормально сохранили, то перезапишете Ваш старый image file новым снимком. Или, по-другому, можете сохранить образ под новым именем, ровно так, как мы только что делали.

В дополнение к .image файлу так же будет .change файл. Этот файл содержит журнал (log) всех изменений с исходным кодом, который Вы создали, используя стандартные инструменты. Большую часть времени Вам не потребуется следить за этим файлом совсем. Но как мы увидим, как бы то ни было, .changes файл может быть очень полезен для отладки или восстановления потерянных изменений. Однако, подробнее об том позже.

Образ, с которым Вы сейчас непосредственно работаете, является потомком оригинального образа Smalltalk--80, созданного в конце 70-ых годов. Некоторые из теперешних объектов существуют на протяжении десятилетий!

Вы можете подумать, что образ~--- это ключевой механизм для хранения и управления программными проектами, но вы ошибаетесь. Как мы сможем очень скоро увидеть, есть намного лучшие инструменты для управления кодом и совместного использования программного обеспечивания, разработанные командами. Образы очень полезны, но Вы должны научиться быть крайне непринуждёнными в создании и удалении образов, ровно с тех самых пор, когда инструменты по типу Monticello предлагают намного более лучшие пути для управления версиями и разделением кода между разработчиками.

\dothis{Используйте мышку (и соответствующие клавиши-модфикаторы), meta-клик на BouncingAtomsMorph}

Вы увидите целую коллекцию разноцветных кружков, которые все вместе называются морфик гало класса BouncingAtomsMorph. Каждый кружок называется "ручкой". Клик на розовую ручку содержит в себе крест; BouncingAtomsMorph должен свернуться.

\section{Рабочее пространство и transcript}

\dothis{ Закройте все открытые окна. Откройте transcript и workspace/ рабочую область. (transcript можно открыть  через \menu{World \go Tools...}submenu.)}

\dothis{Установите (измените размеры) transcript и workspace окон  так, чтобы рабочая область перекрывала transcript. }

Вы можете изменить размеры окна  либо потянув за один из углов, либо воспользоваться  мета-кликом, чтобы вызвать морфик гало и уже на нём потянуть  желтую "ручку" правой кнопкой.

В любое время активно только одно окно; оно находится на переднем плане и имеет выделенные границы.

Transcript~--- это объект, который часто используется для регистрации системных сообщений, своего рода, "системная консоль".

Рабочая область полезна для набора фрагментов кода на  smalltalk, с которыми впоследствии вы  бы хотели поэкспериментировать. Вы можете в этой рабочей области просто набирать произвольный   текст, который хотите не забыть, например, список дел или инструкций для того, кто потом будет пользоваться вашим образом pharo. Рабочие области часто используют для документации снимков образов, как и в случае стандартного образа, который мы загрузили ранее. (См. Рис. 1.2)



\dothis{Наберите следующий текст в рабочей области:}

\begin{code}{}
Transcript show: 'hello world'; cr.
\end{code}

Попробуйте дважды щелкнуть на рабочей области в различных местах набранного текста. Стоит заметить, что будет выбрано слово, строка или целый текст в зависимости от того где вы щелкнули: рядом со словом, в конце строки или в конце целого текста.

\dothis{Выберите текст, который вы набрали только что и действие-click. Выберите пункт подменю do it (d).}

Обратите внимание, как два слова "hello world" появляются в transcript-окне. (Рис.1.8) Проделайте это снова. (Буква (d), стоящая рядом с do it(d) в подменю говорит о том, что горячая клавиша to do~--- это CMD-d. Подробнее об этом в следующем разделе!)

Рис.1.8: Частично перекрытые окна. Активно окно рабочей области.

\section{Клавиши быстрого вызова}

Для оценки выражений вам не всегда нужно использовать действие-клик. Вместо этого, вы можете воспользоваться "горячими клавишами"/клавишами быстрого вызова. Это зарезервированные выражения в меню. В зависимости от вашей платформы, вы можете нажать одну из клавиш-модификаторов(Ctrl, Alt, command, или meta). (Мы будем указывать их в общем как CMD-key/CMD-ключ).

\dothis{Теперь снова вычислите/оцените выражение, но уже с использованием горячей клавиши CMD-d.}

Перед тем, как это сделать, обратите внимание на print it, inspect it и explore it. Давайте рассмотрим каждое из этих действий.

\dothis{Наберите выражение 3 + 4 в рабочей области. Теперь сделайте это с помощью горячих клавиш.}

Не удивляйтесь, если увидите, что ничего не произошло! Вы только что послали сообщение + с аргументом 4 номеру 3. Обычно результат 7 вычисляется и возвращается вам, но так как рабочая область попросту не знает, что с ним делать дальше, - отбрасывает его. Если захотите увидеть результат,  распечатайте его. Print it обычно собирает /компилирует выражение, выполняет его, посылает сообщение  printString результату и отображает результирующую строку.

\dothis{Наберите 3+4 и выберите print it (CMD-p).}

На этот раз мы увидим ожидаемый результат (Рис. 1.9).

Рис.1.9: "Print it" вместо "do it"

\begin{code}{}
3 + 4 --> 7
\end{code}

Мы используем обозначение -> как соглашение в этой книге, чтобы показать, к чему приведет Pharo-выражение после того, как вы получите результат применяя print it.

\dothis{Удалите выделенный текст "7" (Pharo должен сделать это за вас так, чтобы вы смогли потом нажать только delete). Наберите 3 + 4 снова и выберите inspect it (CMD-i).}

Удалите выделенный текст "7" (Pharo должен сделать это за вас так, чтобы вы смогли потом нажать только delete). Наберите 3 + 4 снова и выберите inspect it (CMD-i).  После этого появится новое окно, которое называется инспектор, с заголовком SmallInteger: 7 (См. Рис.1.10). Инспектор~--- очень полезный инструмент, который позволит вам просматривать и взаимодействовать с любым объектом в системе.  Название говорит нам о том, что 7~--- это экземпляр класса SmallInteger. Левая панель предоставляет нам возможность просматривать переменные экземпляра объекта/класса/ , значения которых выведены на правой панели. Нижняя панель может быть  использована  для написания выражений чтобы отправить их потом объекту.

\dothis{ Наберите self squared в нижней панели инспектора на 7 и print it}

\dothis{ Закройте инспектора. Наберите выражение Object в рабочей области и выберите explore it (CMD-I, i в верхнем регистре).}

В этот раз вы увидите окно, помеченное Object, содержащее текст \menu{\go root:Object}. Кликнете по треугольнику, чтобы раскрыть его (Рис.1.11).

Рис.1.11: Изучение Object

Explorer похож на inspector, за исключением древовидной структуры сложного объекта. В этом случае, объект, который мы наблюдаем, это класс Object. Мы можем видеть всю информацию, которая хранится в этом классе и легко переходить ко всем его частям.


\section{Класс Browser}

Класс браузер\footnote{Странно, что это слово может употребляться и как "системный браузер" или как "кодовый браузер". Pharo использует OmniBrowser реализации  браузера, которые могут быть известны под названиями:  "OB" или "Package browser". В этой книге мы просто используем термин "браузер" или, в случае двусмысленности, "класс браузер".}~--- один из ключевых инструментов, используемых в программировании. Как мы увидим далее, несколько интересных браузеров доступны в  Pharo, но это основной, который вы найдёте в любом образе.

\dothis{Откройте браузер и выберите \menu{ World \go Class browser.}}

Рис. 1.12: Браузер демонстрирует printString метод класса object.

Мы можем видеть браузер на Рис.1.12. Заголовок окна указывает, что мы просматриваем класс Object.

При первом открытии браузера все панели пусты, за исключением одной~--- крайней левой. Эта первая панель перечисляет все известные пакеты, которые содержат группы связанных классов.

\dothis{Кликнете по  Kernel пакету.}

Так вторая панель покажет нам список всех классов выбранного пакета.

\dothis{Выберите класс Object.}

Теперь в оставшихся панелях появится текст. Третья панель выводит протоколы текущего выбранного класса. Это удобно при группировке связанных методов. Если вы не выбрали ни одного протокола, то четвертая панель покажет все методы.

\dothis{Выберите printing протокол.}

Вы можете прокрутить вниз для его поиска.  Теперь вы будете видеть в четвертом блоке только те методы, которые связаны с печатью.

\dothis{Выберите printString метод.}


Теперь вы увидите на нижней панели исходный код метода printString, используемый всеми объектами системы (кроме тех, которые отвергают его).


\section{Поиск классов}

Есть несколько способов найти класс в Pharo. Во-первых, как мы видели только что выше, нужно знать (или предполагать), к какой категории он принадлежит и ориентироваться при помощи браузера.

Второй способ заключается в том, чтобы послать browse сообщение  классу, попросив при этом открыть результат в браузере. Предположим, что мы хотим просмотреть класс Boolean.

\dothis{Наберите Boolean  browse в рабочей области и do it.}

Браузер откроет класс Boolean (Рис.1.13). Есть также горячая клавиша CMD-b(browser), которую можете использовать в любом инструменте где вы найдете имя класса; выберите имя и наберите CMD-b.

\dothis{Используйте горячую клавишу, чтобы просмотреть класс Boolean.}

Заметим, что когда Boolean класс выбран, а протоколы или методы~--- нет, то вместо исходного кода метода мы видим определение класса (Рис. 1.13). Это не что иное как обычная посылка Smalltalk сообщения родительскому классу с просьбой создать подкласс. Здесь мы видим, как  класс Object просят создать подкласс с именем Boolean без переменных экземпляра, переменных класса или "пул словари" и поместить класс Boolean в  Kernel-Objects категорию. Если вы кликнете по \button {?} в нижней части второй панели (отвечающей за классы), то увидите комментарии к классу в специальной области (смотрите Рис. 1.14)

Рис.1.13 Браузер демонстрирует определение класса Boolean.

Рис.1.14: Комментарии класса Boolean.

Часто самый быстрый способ найти класс это искать его по имени. Для примера, предположим, что вам нужно найти какой-либо известный класс, представляющий даты и время.

\dothis{Наведите мышь на пакет панель браузера и наберите CMD-f или выберите find class\dots (f) действием кнопкой мыши. Наберите "time" в диалоговом окне и accept it.}

Вам будет предоставлен список классов, имена которых содержат "time" (Рис. 1.15). Выберите один, скажем, Time и браузер покажет его наряду с другими возможными вариантами. Если хотите просмотреть другой класс, выберите его имя,  и наберите CMD-b.

Рис. 1.15 : Поиск классов по имени.

Обратите внимание, что если вы наберете полное (и с заглавной буквы) имя класса в диалоговом окне, то браузер перейдет непосредственно к этому классу, не показывая вам список вариантов.

\section{Поиск методов}

Иногда вы можете предположить имя метода, или по крайней мере, часть имени этого метода,ведь это сделать проще, чем угадать имя класса. Например, если вы хотите узнать текущее время, то наверняка ожидаете, что метод будет называться "now" или содержать в своем имени подстроку "now". Как его обнаружить? Метод method finder поможет вам в этом.

\dothis{Выберите \menu{World \go Tools \dots \go Method finder}. Наберите "now" в верхней левой панели и accept it (или нажмите только клавишу RETURN).}

Метод finder покажет список всех имен методов, содержащих подстроку "now". Прокрутите его самостоятельно и перетащите курсор на этот список и наберите "n"; Этот трюк работает во всех прокручиваемых окнах. Выберите "now",  и правая сторона панели  выведет все классы, которые определяют метод с этим именем, как показано на Рис.1.16. После выбора одного из них браузер откроет этот класс.

В других случаях, когда вы предполагаете, что метод существует, но не знаете, как он может быть назван, т.е. под каким именем его нужно искать~---  здесь вновь нам поможет method finder. Для примера предположим, что вам нужно найти метод, который переводит любую строку в верхний регистр, то есть, например,  строку 'eureka'  в 'EUREKA'.

Рис.1.16: Метод finder показывает все классы, определяющие метод  с именем "now".

\dothis{ Напечатайте 'eureka' . 'EUREKA' в окошко method finder и нажмите клавишу RETURN, как показано на Рис. 1.17}

Метод finder предложит метод, который сможет сделать то, что мы хотим.\footnote{Если всплывающее окно предупреждает об устаревшем методе~--- не паникуйте, просто method finder пытается вывести всех похожих методов, включая устаревшие. Кликнете \button{Proceed}.}

Звездочка в начале строки указывает  на то,  что на правой панели  метод finder показывает тот метод, который действительно использовался для достижения требуемого результата. Так, звездочка перед String asUppercase сообщает нам, что метод asUppercase, определенный в классе String был выполнен и нужный результат возвращен. Методы, у которых нет звездочки в начале, просто другие методы, у которых такие же имена, как и у тех, которые возвращают ожидаемый результат.
Так, метод \ct{Character>>>asUppercase} не работает на нашем примере, потому что 'eureka' не объект класса Character.

Вы можете также использовать метод finder и для поиска методов с аргументами, например, если захотите найти метод, позволяющий отыскать наибольший общий делитель двух чисел, то используйте в качестве примера 25. 35. 5. Еще методу finder можно давать не один, а несколько примеров для сужения области поиска. Справка на нижней панели покажет, как это сделать.

Рис. 1.17: Пример поиска метода.

\section{Определение нового метода}

Появление Test Driven Development\footnote{Kent Beck, Test Driven Development: By Example. Addison--Wesley, 2003, ISBN 0-321-14653-0. } (TDD, Разработка через тестирование) изменило путь написания кода. Идея TDD заключается в том, что мы пишем тест, который определит поведение нашего кода  до написания самого кода.  Только после этого мы пишем код, которому удовлетворяет наш тест.

Предположим, что нам нужно написать метод, который "says something
loudly and with emphasis" ("говорит о чем-то громко и с выражением"). Что бы это значило? Какое подходящее название можно дать этому методу? Как мы можем быть уверенными, что программисты, которые будут поддерживать наш метод в будущем, будут иметь однозначно описание того, для чего он создан? Мы можем ответить на все эти вопросы, приведя пример:

Когда мы посылаем сообщение shout строке "Don't panic" , результат должен быть "DON'T PANIC!".

Теперь чтобы превратить этот пример во что-то, понятное системе, мы обратимся к тестовому методу:

\begin{method}[doit]{Тест для метода shout}
testShout
    self assert: ('Don''t panic' shout = 'DON''T PANIC!')
\end{method}

Как мы создаем новый метод в Pharo? Во-первых, мы должны решить, какому классу будет принадлежать метод shout. В этом случае shout метод мы будем тестировать в классе String, следовательно, следуя соглашению, соответствующий тест будет входить в класс с названием  StringTest.

Рис.1.18: Новый шаблон метода в классе StringTest.

\dothis{Откройте браузер для класса StringTest и выберите соответствующий протокол для нашего метода, в этом случае~--- \menu{tests-converting}, как показано на Рис.1.18. Подчеркнутый текст в нижней панели~--- шаблон метода  напоминает нам, как выглядит метод Smalltalk-а. Удалите там всё и поместите туда код из метода 1.1.}

После ввода текста в браузер, вы заметите что нижняя панель подсвечена красным. Это означает, что она содержит несохраненные изменения. Так выберите accept (s) действием-кликом на нижней панели или просо наберите  CMD-s, чтобы скомпилировать и сохранить ваш метод.

Если это первый раз, когда вы ввели какие-либо изменения в этом коде, то скорее всего вам будет предложено ввести свое имя.  Так как много людей поддерживают код, то становится важным следить за всеми, кто создает или изменяет методы. Просто введите ваши имя и фамилию без пробелов и разделителей (точек).

Так как до сих пор не было метода shout, то браузер попросит вас подтвердить это имя, что действительно вы имели в виду именно такое написание имени. И предложит несколько других имен,  которые вы могли подразумевать (рис.1.20).  Это может быть полезно, если в имени у вас закралась опечатка, но в данном случае это не так - мы действительно хотим создать метод shout, поэтому подтвердите это, выбрав первую опцию из меню выбора, как на Рис.1.20.

Рис.1.19: Введите ваше имя.

\dothis{Запустите ваш новый созданный тест: откройте the SUnit TestRunner из \menu{World}-меню.}

Левые две панели немного похожи на верхние панели в браузере. Левая панель содержит список категорий, в который входят только те(категории), которые содержат тестовые классы.

\dothis{Выберите CollectionsTests-Text и панель справа покажет вам все тестовые классы, которые содержит данная категория. Здесь есть класс StringTest. Имена классов уже выбраны, поэтому просто кликнете \menu{Run Selected} для запуска всех этих тестов.}

Вы должны увидеть сообщение, подобное тому, что показано на Рис.1.21, которое указывает на наличие ошибки при запуске тестов. Список тестов, который привел к её появлению, отображается в нижней правой части окна; как вы видите, StringTest"\#testShout  виновен в этом (Заметим, что StringTest"\#testShout позволяет выявить метод testShout в классе StringTest). Если вы нажмете на эту строчку текста, то тест с ошибкой выполниться снова, но на этот раз  вы увидите появление ошибки сообщением: \ct{"MessageNotUnderstood: ByteString"shout"}.

Открывшееся окно с сообщением об ошибке~--- это Smalltalk отладчик (Smalltalk debugger) (см. Рис.1.22). Дальнейшее подробное  изучение отладчика продолжиться в главе 6.

Конечно, эту ошибку мы ожидали, потому что еще не существует метода, позволяющего обработать данную стоку, то есть нет метода, который говорит как shout.

Рис.1.20: Accepting the StringTest method testShout.

Тем не менее, это хорошая практика, чтобы убедиться, что тест не пройден, и потому это подтверждает, что мы правильно настроили машину тестирования. Как только вы увидели ошибку, вы можете нажать кнопку \button{Abandon} (Остановить), то есть  остановить запущенный тест, которая закроет окно отладчика. Заметим, что вы можете определить со  Smalltalk-ом отсутствующие методы, используя кнопку \button{Create}, редактировать вновь созданный метод в отладчике, а затем нажать \button{Proceed}, то есть выполнить с тестом.

Теперь давайте определим метод, который скажет, что тест пройден!

\dothis{Выберите класс String в браузере, выберите \menu{converting} протокол, наберите текст метода 1.2 после метода создания шаблона и \menu{accept it} (Замечание: чтобы получить a \ct{^}, наберите {$\hat{~}$}).}


\begin{method}[doit]{Метод shout}
shout
    {tab}self asUppercase, '!'
\end{method}

Запятая~--- это операция для связи строк, поэтому к телу этого метода добавлен восклицательный знак, означающий верхний регистр всех объектов String, которым было послано сообщение shout.  \ct{^} говорит Pharo, что выражение, которое последует это на самом деле ответ, который возвращается из метода, в этом случае это навая присоединенная строка.

Этот метод работает? Давайте проверим это, запустив тесты.

\dothis{Нажмите на \menu{Run Selected} снова в test runner и на этот раз вы увидите зеленую полоску и текст о том, что все тесты запустились без сбоев и ошибок.}

Рис.1.21: Запуск String тесов

Рис.1.22: Отладчик

Когда вы дойдете до зеленой полоски /достигнете зеленую полоску/, то хорошо бы сохранить свою работу и пойти на перерыв. Так что сделайте это прямо сейчас!

Рис.1.23: Метод shout, определенный в классе String.


\section{Заключение}

Эта глава познакомила вас со средой разработки Pharo и продемонстрировала возможности таких методов, как браузер, метод finder, и test runner. Так же вы увидели маленький кусочек синтаксиса Pharo, но далеко не полностью смогли его понять.


\begin{enumerate}




\item{Pharo система состоит из виртуальной машины, исходных файлов и image и change файлов.}


\item{При восстановлении image файла, вы обнаружите все те созданные вами при последнем сохранении объекты находятся в том же состоянии.}




\item{Pharo предназначен для работы с тремя кнопками мыши: клик, действие-клик или мета-клик. Если у вас нет мыши с тремя кнопками, то можно использовать клавиши-модификаторы для получения того же эффекта.}

\item{Кликнете по фону Pharo и вы запустите World-меню и другие различные настройки.}

\item{Рабочее пространство~--- это инструмент для написания и оценки /вычисления/ фрагментов кода. Так же его можно использовать для хранения произвольного текста.}

\item{Для оценки кода вы можете использовать горячие клавиши. Вот наиболее важные из них: \menu{do it}
 (CMD-d), \menu{print it} (CMD-p), \menu{inspect it} (CMD-i), \menu{explore it} (CMD-I) и
\menu{browse it}


 (CMD-b).}

\item{Браузер является основным инструментом для просмотра кода, а также для написания нового.}

\item{Runner tester~--- инструмент для выполнения модульных тестов. Он также поддерживает TDD.}

\end{enumerate}

	





\end{document}
